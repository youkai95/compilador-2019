Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    printx
    scanx

Grammar

Rule 0     S' -> program
Rule 1     empty -> <empty>
Rule 2     binary_operator -> v_expr plus v_expr
Rule 3     binary_operator -> v_expr minus v_expr
Rule 4     binary_operator -> v_expr star v_expr
Rule 5     binary_operator -> v_expr div v_expr
Rule 6     program -> class_expresion semicolon program_a
Rule 7     program_a -> class_expresion semicolon program_a
Rule 8     program_a -> empty
Rule 9     neg -> not idx
Rule 10    compl -> complement idx
Rule 11    assign_expresion -> idx assign expr
Rule 12    declare_expresion -> idx doubledot idx assign expr
Rule 13    declare_expresion -> idx doubledot idx
Rule 14    declare_method -> idx doubledot idx
Rule 15    new_expresion -> new idx
Rule 16    class_expresion -> class white_space idx ocurly feature
Rule 17    class_expresion -> class idx inherits idx ocurly feature
Rule 18    feature -> method_decl feature
Rule 19    feature -> property_decl feature
Rule 20    feature -> ccurly
Rule 21    method_decl -> idx obracket formal cbracket doubledot idx ocurly expr ccurly semicolon feature
Rule 22    formal -> declare_method formal_a
Rule 23    formal -> empty
Rule 24    formal_a -> comma declare_method formal_a
Rule 25    formal_a -> empty
Rule 26    expr -> assign_expresion
Rule 27    expr -> while_expresion
Rule 28    expr -> v_expr
Rule 29    comparison_expresion -> v_expr less v_expr
Rule 30    comparison_expresion -> v_expr less_equal v_expr
Rule 31    comparison_expresion -> v_expr equal v_expr
Rule 32    v_expr -> conditional_expresion
Rule 33    v_expr -> let_expresion
Rule 34    v_expr -> case_expresion
Rule 35    v_expr -> dispatch_expresion
Rule 36    v_expr -> dispatch_instance
Rule 37    v_expr -> block_expresion
Rule 38    v_expr -> binary_operator
Rule 39    v_expr -> neg
Rule 40    v_expr -> compl
Rule 41    v_expr -> is_void
Rule 42    v_expr -> new_expresion
Rule 43    v_expr -> obracket v_expr cbracket
Rule 44    v_expr -> term
Rule 45    v_expr -> comparison_expresion
Rule 46    term -> var
Rule 47    term -> num
Rule 48    term -> str
Rule 49    term -> bool
Rule 50    var -> idx
Rule 51    num -> number
Rule 52    str -> string
Rule 53    bool -> true
Rule 54    bool -> false
Rule 55    block_expresion -> ocurly block_expr ccurly
Rule 56    block_expr -> expr semicolon block_expr_a
Rule 57    block_expr_a -> expr semicolon block_expr_a
Rule 58    block_expr_a -> empty
Rule 59    property_decl -> declare_expresion semicolon feature
Rule 60    conditional_expresion -> if v_expr then expr else expr fi
Rule 61    is_void -> isvoid expr
Rule 62    while_expresion -> while v_expr loop expr pool
Rule 63    case_expresion -> case expr of case_list esac
Rule 64    case_list -> declare_method case_expr expr semicolon case_list_a
Rule 65    case_list_a -> declare_method case_expr expr semicolon case_list_a
Rule 66    case_list_a -> empty
Rule 67    let_expresion -> let let_declr_list inx expr
Rule 68    let_declr_list -> declare_expresion let_declr_list_a
Rule 69    let_declr_list_a -> declare_expresion let_declr_list_a
Rule 70    let_declr_list_a -> empty
Rule 71    dispatch_expresion -> idx obracket dispatch_p_list cbracket
Rule 72    dispatch_instance -> idx dot idx obracket dispatch_p_list cbracket
Rule 73    dispatch_instance -> idx arrobe idx dot idx obracket dispatch_p_list cbracket
Rule 74    dispatch_p_list -> v_expr dispatch_p_list
Rule 75    dispatch_p_list -> empty

Terminals, with rules where they appear

arrobe               : 73
assign               : 11 12
case                 : 63
case_expr            : 64 65
cbracket             : 21 43 71 72 73
ccurly               : 20 21 55
class                : 16 17
comma                : 24
complement           : 10
div                  : 5
dot                  : 72 73
doubledot            : 12 13 14 21
else                 : 60
equal                : 31
error                : 
esac                 : 63
false                : 54
fi                   : 60
idx                  : 9 10 11 12 12 13 13 14 14 15 16 17 17 21 21 50 71 72 72 73 73 73
if                   : 60
inherits             : 17
inx                  : 67
isvoid               : 61
less                 : 29
less_equal           : 30
let                  : 67
loop                 : 62
minus                : 3
new                  : 15
not                  : 9
number               : 51
obracket             : 21 43 71 72 73
ocurly               : 16 17 21 55
of                   : 63
plus                 : 2
pool                 : 62
printx               : 
scanx                : 
semicolon            : 6 7 21 56 57 59 64 65
star                 : 4
string               : 52
then                 : 60
true                 : 53
while                : 62
white_space          : 16

Nonterminals, with rules where they appear

assign_expresion     : 26
binary_operator      : 38
block_expr           : 55
block_expr_a         : 56 57
block_expresion      : 37
bool                 : 49
case_expresion       : 34
case_list            : 63
case_list_a          : 64 65
class_expresion      : 6 7
comparison_expresion : 45
compl                : 40
conditional_expresion : 32
declare_expresion    : 59 68 69
declare_method       : 22 24 64 65
dispatch_expresion   : 35
dispatch_instance    : 36
dispatch_p_list      : 71 72 73 74
empty                : 8 23 25 58 66 70 75
expr                 : 11 12 21 56 57 60 60 61 62 63 64 65 67
feature              : 16 17 18 19 21 59
formal               : 21
formal_a             : 22 24
is_void              : 41
let_declr_list       : 67
let_declr_list_a     : 68 69
let_expresion        : 33
method_decl          : 18
neg                  : 39
new_expresion        : 42
num                  : 47
program              : 0
program_a            : 6 7
property_decl        : 19
str                  : 48
term                 : 44
v_expr               : 2 2 3 3 4 4 5 5 28 29 29 30 30 31 31 43 60 62 74
var                  : 46
while_expresion      : 27

Parsing method: LALR

state 0

    (0) S' -> . program
    (6) program -> . class_expresion semicolon program_a
    (16) class_expresion -> . class white_space idx ocurly feature
    (17) class_expresion -> . class idx inherits idx ocurly feature

    class           shift and go to state 3

    program                        shift and go to state 1
    class_expresion                shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (6) program -> class_expresion . semicolon program_a

    semicolon       shift and go to state 4


state 3

    (16) class_expresion -> class . white_space idx ocurly feature
    (17) class_expresion -> class . idx inherits idx ocurly feature

    white_space     shift and go to state 5
    idx             shift and go to state 6


state 4

    (6) program -> class_expresion semicolon . program_a
    (7) program_a -> . class_expresion semicolon program_a
    (8) program_a -> . empty
    (16) class_expresion -> . class white_space idx ocurly feature
    (17) class_expresion -> . class idx inherits idx ocurly feature
    (1) empty -> .

    class           shift and go to state 3
    $end            reduce using rule 1 (empty -> .)

    class_expresion                shift and go to state 7
    program_a                      shift and go to state 8
    empty                          shift and go to state 9

state 5

    (16) class_expresion -> class white_space . idx ocurly feature

    idx             shift and go to state 10


state 6

    (17) class_expresion -> class idx . inherits idx ocurly feature

    inherits        shift and go to state 11


state 7

    (7) program_a -> class_expresion . semicolon program_a

    semicolon       shift and go to state 12


state 8

    (6) program -> class_expresion semicolon program_a .

    $end            reduce using rule 6 (program -> class_expresion semicolon program_a .)


state 9

    (8) program_a -> empty .

    $end            reduce using rule 8 (program_a -> empty .)


state 10

    (16) class_expresion -> class white_space idx . ocurly feature

    ocurly          shift and go to state 13


state 11

    (17) class_expresion -> class idx inherits . idx ocurly feature

    idx             shift and go to state 14


state 12

    (7) program_a -> class_expresion semicolon . program_a
    (7) program_a -> . class_expresion semicolon program_a
    (8) program_a -> . empty
    (16) class_expresion -> . class white_space idx ocurly feature
    (17) class_expresion -> . class idx inherits idx ocurly feature
    (1) empty -> .

    class           shift and go to state 3
    $end            reduce using rule 1 (empty -> .)

    class_expresion                shift and go to state 7
    program_a                      shift and go to state 15
    empty                          shift and go to state 9

state 13

    (16) class_expresion -> class white_space idx ocurly . feature
    (18) feature -> . method_decl feature
    (19) feature -> . property_decl feature
    (20) feature -> . ccurly
    (21) method_decl -> . idx obracket formal cbracket doubledot idx ocurly expr ccurly semicolon feature
    (59) property_decl -> . declare_expresion semicolon feature
    (12) declare_expresion -> . idx doubledot idx assign expr
    (13) declare_expresion -> . idx doubledot idx

    ccurly          shift and go to state 20
    idx             shift and go to state 16

    feature                        shift and go to state 17
    method_decl                    shift and go to state 18
    property_decl                  shift and go to state 19
    declare_expresion              shift and go to state 21

state 14

    (17) class_expresion -> class idx inherits idx . ocurly feature

    ocurly          shift and go to state 22


state 15

    (7) program_a -> class_expresion semicolon program_a .

    $end            reduce using rule 7 (program_a -> class_expresion semicolon program_a .)


state 16

    (21) method_decl -> idx . obracket formal cbracket doubledot idx ocurly expr ccurly semicolon feature
    (12) declare_expresion -> idx . doubledot idx assign expr
    (13) declare_expresion -> idx . doubledot idx

    obracket        shift and go to state 23
    doubledot       shift and go to state 24


state 17

    (16) class_expresion -> class white_space idx ocurly feature .

    semicolon       reduce using rule 16 (class_expresion -> class white_space idx ocurly feature .)


state 18

    (18) feature -> method_decl . feature
    (18) feature -> . method_decl feature
    (19) feature -> . property_decl feature
    (20) feature -> . ccurly
    (21) method_decl -> . idx obracket formal cbracket doubledot idx ocurly expr ccurly semicolon feature
    (59) property_decl -> . declare_expresion semicolon feature
    (12) declare_expresion -> . idx doubledot idx assign expr
    (13) declare_expresion -> . idx doubledot idx

    ccurly          shift and go to state 20
    idx             shift and go to state 16

    method_decl                    shift and go to state 18
    feature                        shift and go to state 25
    property_decl                  shift and go to state 19
    declare_expresion              shift and go to state 21

state 19

    (19) feature -> property_decl . feature
    (18) feature -> . method_decl feature
    (19) feature -> . property_decl feature
    (20) feature -> . ccurly
    (21) method_decl -> . idx obracket formal cbracket doubledot idx ocurly expr ccurly semicolon feature
    (59) property_decl -> . declare_expresion semicolon feature
    (12) declare_expresion -> . idx doubledot idx assign expr
    (13) declare_expresion -> . idx doubledot idx

    ccurly          shift and go to state 20
    idx             shift and go to state 16

    property_decl                  shift and go to state 19
    feature                        shift and go to state 26
    method_decl                    shift and go to state 18
    declare_expresion              shift and go to state 21

state 20

    (20) feature -> ccurly .

    semicolon       reduce using rule 20 (feature -> ccurly .)
    ccurly          reduce using rule 20 (feature -> ccurly .)
    idx             reduce using rule 20 (feature -> ccurly .)


state 21

    (59) property_decl -> declare_expresion . semicolon feature

    semicolon       shift and go to state 27


state 22

    (17) class_expresion -> class idx inherits idx ocurly . feature
    (18) feature -> . method_decl feature
    (19) feature -> . property_decl feature
    (20) feature -> . ccurly
    (21) method_decl -> . idx obracket formal cbracket doubledot idx ocurly expr ccurly semicolon feature
    (59) property_decl -> . declare_expresion semicolon feature
    (12) declare_expresion -> . idx doubledot idx assign expr
    (13) declare_expresion -> . idx doubledot idx

    ccurly          shift and go to state 20
    idx             shift and go to state 16

    feature                        shift and go to state 28
    method_decl                    shift and go to state 18
    property_decl                  shift and go to state 19
    declare_expresion              shift and go to state 21

state 23

    (21) method_decl -> idx obracket . formal cbracket doubledot idx ocurly expr ccurly semicolon feature
    (22) formal -> . declare_method formal_a
    (23) formal -> . empty
    (14) declare_method -> . idx doubledot idx
    (1) empty -> .

    idx             shift and go to state 29
    cbracket        reduce using rule 1 (empty -> .)

    formal                         shift and go to state 30
    declare_method                 shift and go to state 31
    empty                          shift and go to state 32

state 24

    (12) declare_expresion -> idx doubledot . idx assign expr
    (13) declare_expresion -> idx doubledot . idx

    idx             shift and go to state 33


state 25

    (18) feature -> method_decl feature .

    semicolon       reduce using rule 18 (feature -> method_decl feature .)
    ccurly          reduce using rule 18 (feature -> method_decl feature .)
    idx             reduce using rule 18 (feature -> method_decl feature .)


state 26

    (19) feature -> property_decl feature .

    semicolon       reduce using rule 19 (feature -> property_decl feature .)
    ccurly          reduce using rule 19 (feature -> property_decl feature .)
    idx             reduce using rule 19 (feature -> property_decl feature .)


state 27

    (59) property_decl -> declare_expresion semicolon . feature
    (18) feature -> . method_decl feature
    (19) feature -> . property_decl feature
    (20) feature -> . ccurly
    (21) method_decl -> . idx obracket formal cbracket doubledot idx ocurly expr ccurly semicolon feature
    (59) property_decl -> . declare_expresion semicolon feature
    (12) declare_expresion -> . idx doubledot idx assign expr
    (13) declare_expresion -> . idx doubledot idx

    ccurly          shift and go to state 20
    idx             shift and go to state 16

    declare_expresion              shift and go to state 21
    feature                        shift and go to state 34
    method_decl                    shift and go to state 18
    property_decl                  shift and go to state 19

state 28

    (17) class_expresion -> class idx inherits idx ocurly feature .

    semicolon       reduce using rule 17 (class_expresion -> class idx inherits idx ocurly feature .)


state 29

    (14) declare_method -> idx . doubledot idx

    doubledot       shift and go to state 35


state 30

    (21) method_decl -> idx obracket formal . cbracket doubledot idx ocurly expr ccurly semicolon feature

    cbracket        shift and go to state 36


state 31

    (22) formal -> declare_method . formal_a
    (24) formal_a -> . comma declare_method formal_a
    (25) formal_a -> . empty
    (1) empty -> .

    comma           shift and go to state 38
    cbracket        reduce using rule 1 (empty -> .)

    formal_a                       shift and go to state 37
    empty                          shift and go to state 39

state 32

    (23) formal -> empty .

    cbracket        reduce using rule 23 (formal -> empty .)


state 33

    (12) declare_expresion -> idx doubledot idx . assign expr
    (13) declare_expresion -> idx doubledot idx .

    assign          shift and go to state 40
    semicolon       reduce using rule 13 (declare_expresion -> idx doubledot idx .)
    idx             reduce using rule 13 (declare_expresion -> idx doubledot idx .)
    inx             reduce using rule 13 (declare_expresion -> idx doubledot idx .)


state 34

    (59) property_decl -> declare_expresion semicolon feature .

    ccurly          reduce using rule 59 (property_decl -> declare_expresion semicolon feature .)
    idx             reduce using rule 59 (property_decl -> declare_expresion semicolon feature .)


state 35

    (14) declare_method -> idx doubledot . idx

    idx             shift and go to state 41


state 36

    (21) method_decl -> idx obracket formal cbracket . doubledot idx ocurly expr ccurly semicolon feature

    doubledot       shift and go to state 42


state 37

    (22) formal -> declare_method formal_a .

    cbracket        reduce using rule 22 (formal -> declare_method formal_a .)


state 38

    (24) formal_a -> comma . declare_method formal_a
    (14) declare_method -> . idx doubledot idx

    idx             shift and go to state 29

    declare_method                 shift and go to state 43

state 39

    (25) formal_a -> empty .

    cbracket        reduce using rule 25 (formal_a -> empty .)


state 40

    (12) declare_expresion -> idx doubledot idx assign . expr
    (26) expr -> . assign_expresion
    (27) expr -> . while_expresion
    (28) expr -> . v_expr
    (11) assign_expresion -> . idx assign expr
    (62) while_expresion -> . while v_expr loop expr pool
    (32) v_expr -> . conditional_expresion
    (33) v_expr -> . let_expresion
    (34) v_expr -> . case_expresion
    (35) v_expr -> . dispatch_expresion
    (36) v_expr -> . dispatch_instance
    (37) v_expr -> . block_expresion
    (38) v_expr -> . binary_operator
    (39) v_expr -> . neg
    (40) v_expr -> . compl
    (41) v_expr -> . is_void
    (42) v_expr -> . new_expresion
    (43) v_expr -> . obracket v_expr cbracket
    (44) v_expr -> . term
    (45) v_expr -> . comparison_expresion
    (60) conditional_expresion -> . if v_expr then expr else expr fi
    (67) let_expresion -> . let let_declr_list inx expr
    (63) case_expresion -> . case expr of case_list esac
    (71) dispatch_expresion -> . idx obracket dispatch_p_list cbracket
    (72) dispatch_instance -> . idx dot idx obracket dispatch_p_list cbracket
    (73) dispatch_instance -> . idx arrobe idx dot idx obracket dispatch_p_list cbracket
    (55) block_expresion -> . ocurly block_expr ccurly
    (2) binary_operator -> . v_expr plus v_expr
    (3) binary_operator -> . v_expr minus v_expr
    (4) binary_operator -> . v_expr star v_expr
    (5) binary_operator -> . v_expr div v_expr
    (9) neg -> . not idx
    (10) compl -> . complement idx
    (61) is_void -> . isvoid expr
    (15) new_expresion -> . new idx
    (46) term -> . var
    (47) term -> . num
    (48) term -> . str
    (49) term -> . bool
    (29) comparison_expresion -> . v_expr less v_expr
    (30) comparison_expresion -> . v_expr less_equal v_expr
    (31) comparison_expresion -> . v_expr equal v_expr
    (50) var -> . idx
    (51) num -> . number
    (52) str -> . string
    (53) bool -> . true
    (54) bool -> . false

    idx             shift and go to state 44
    while           shift and go to state 49
    obracket        shift and go to state 61
    if              shift and go to state 64
    let             shift and go to state 65
    case            shift and go to state 66
    ocurly          shift and go to state 67
    not             shift and go to state 68
    complement      shift and go to state 69
    isvoid          shift and go to state 70
    new             shift and go to state 71
    number          shift and go to state 76
    string          shift and go to state 77
    true            shift and go to state 78
    false           shift and go to state 79

    expr                           shift and go to state 45
    assign_expresion               shift and go to state 46
    while_expresion                shift and go to state 47
    v_expr                         shift and go to state 48
    conditional_expresion          shift and go to state 50
    let_expresion                  shift and go to state 51
    case_expresion                 shift and go to state 52
    dispatch_expresion             shift and go to state 53
    dispatch_instance              shift and go to state 54
    block_expresion                shift and go to state 55
    binary_operator                shift and go to state 56
    neg                            shift and go to state 57
    compl                          shift and go to state 58
    is_void                        shift and go to state 59
    new_expresion                  shift and go to state 60
    term                           shift and go to state 62
    comparison_expresion           shift and go to state 63
    var                            shift and go to state 72
    num                            shift and go to state 73
    str                            shift and go to state 74
    bool                           shift and go to state 75

state 41

    (14) declare_method -> idx doubledot idx .

    comma           reduce using rule 14 (declare_method -> idx doubledot idx .)
    cbracket        reduce using rule 14 (declare_method -> idx doubledot idx .)
    case_expr       reduce using rule 14 (declare_method -> idx doubledot idx .)


state 42

    (21) method_decl -> idx obracket formal cbracket doubledot . idx ocurly expr ccurly semicolon feature

    idx             shift and go to state 80


state 43

    (24) formal_a -> comma declare_method . formal_a
    (24) formal_a -> . comma declare_method formal_a
    (25) formal_a -> . empty
    (1) empty -> .

    comma           shift and go to state 38
    cbracket        reduce using rule 1 (empty -> .)

    formal_a                       shift and go to state 81
    empty                          shift and go to state 39

state 44

    (11) assign_expresion -> idx . assign expr
    (71) dispatch_expresion -> idx . obracket dispatch_p_list cbracket
    (72) dispatch_instance -> idx . dot idx obracket dispatch_p_list cbracket
    (73) dispatch_instance -> idx . arrobe idx dot idx obracket dispatch_p_list cbracket
    (50) var -> idx .

  ! shift/reduce conflict for obracket resolved as shift
    assign          shift and go to state 82
    obracket        shift and go to state 83
    dot             shift and go to state 84
    arrobe          shift and go to state 85
    plus            reduce using rule 50 (var -> idx .)
    minus           reduce using rule 50 (var -> idx .)
    star            reduce using rule 50 (var -> idx .)
    div             reduce using rule 50 (var -> idx .)
    less            reduce using rule 50 (var -> idx .)
    less_equal      reduce using rule 50 (var -> idx .)
    equal           reduce using rule 50 (var -> idx .)
    semicolon       reduce using rule 50 (var -> idx .)
    idx             reduce using rule 50 (var -> idx .)
    inx             reduce using rule 50 (var -> idx .)
    of              reduce using rule 50 (var -> idx .)
    loop            reduce using rule 50 (var -> idx .)
    cbracket        reduce using rule 50 (var -> idx .)
    then            reduce using rule 50 (var -> idx .)
    ccurly          reduce using rule 50 (var -> idx .)
    pool            reduce using rule 50 (var -> idx .)
    else            reduce using rule 50 (var -> idx .)
    if              reduce using rule 50 (var -> idx .)
    let             reduce using rule 50 (var -> idx .)
    case            reduce using rule 50 (var -> idx .)
    ocurly          reduce using rule 50 (var -> idx .)
    not             reduce using rule 50 (var -> idx .)
    complement      reduce using rule 50 (var -> idx .)
    isvoid          reduce using rule 50 (var -> idx .)
    new             reduce using rule 50 (var -> idx .)
    number          reduce using rule 50 (var -> idx .)
    string          reduce using rule 50 (var -> idx .)
    true            reduce using rule 50 (var -> idx .)
    false           reduce using rule 50 (var -> idx .)
    fi              reduce using rule 50 (var -> idx .)

  ! obracket        [ reduce using rule 50 (var -> idx .) ]


state 45

    (12) declare_expresion -> idx doubledot idx assign expr .

    semicolon       reduce using rule 12 (declare_expresion -> idx doubledot idx assign expr .)
    idx             reduce using rule 12 (declare_expresion -> idx doubledot idx assign expr .)
    inx             reduce using rule 12 (declare_expresion -> idx doubledot idx assign expr .)


state 46

    (26) expr -> assign_expresion .

    semicolon       reduce using rule 26 (expr -> assign_expresion .)
    idx             reduce using rule 26 (expr -> assign_expresion .)
    inx             reduce using rule 26 (expr -> assign_expresion .)
    of              reduce using rule 26 (expr -> assign_expresion .)
    plus            reduce using rule 26 (expr -> assign_expresion .)
    minus           reduce using rule 26 (expr -> assign_expresion .)
    star            reduce using rule 26 (expr -> assign_expresion .)
    div             reduce using rule 26 (expr -> assign_expresion .)
    less            reduce using rule 26 (expr -> assign_expresion .)
    less_equal      reduce using rule 26 (expr -> assign_expresion .)
    equal           reduce using rule 26 (expr -> assign_expresion .)
    loop            reduce using rule 26 (expr -> assign_expresion .)
    cbracket        reduce using rule 26 (expr -> assign_expresion .)
    then            reduce using rule 26 (expr -> assign_expresion .)
    ccurly          reduce using rule 26 (expr -> assign_expresion .)
    pool            reduce using rule 26 (expr -> assign_expresion .)
    else            reduce using rule 26 (expr -> assign_expresion .)
    obracket        reduce using rule 26 (expr -> assign_expresion .)
    if              reduce using rule 26 (expr -> assign_expresion .)
    let             reduce using rule 26 (expr -> assign_expresion .)
    case            reduce using rule 26 (expr -> assign_expresion .)
    ocurly          reduce using rule 26 (expr -> assign_expresion .)
    not             reduce using rule 26 (expr -> assign_expresion .)
    complement      reduce using rule 26 (expr -> assign_expresion .)
    isvoid          reduce using rule 26 (expr -> assign_expresion .)
    new             reduce using rule 26 (expr -> assign_expresion .)
    number          reduce using rule 26 (expr -> assign_expresion .)
    string          reduce using rule 26 (expr -> assign_expresion .)
    true            reduce using rule 26 (expr -> assign_expresion .)
    false           reduce using rule 26 (expr -> assign_expresion .)
    fi              reduce using rule 26 (expr -> assign_expresion .)


state 47

    (27) expr -> while_expresion .

    semicolon       reduce using rule 27 (expr -> while_expresion .)
    idx             reduce using rule 27 (expr -> while_expresion .)
    inx             reduce using rule 27 (expr -> while_expresion .)
    of              reduce using rule 27 (expr -> while_expresion .)
    plus            reduce using rule 27 (expr -> while_expresion .)
    minus           reduce using rule 27 (expr -> while_expresion .)
    star            reduce using rule 27 (expr -> while_expresion .)
    div             reduce using rule 27 (expr -> while_expresion .)
    less            reduce using rule 27 (expr -> while_expresion .)
    less_equal      reduce using rule 27 (expr -> while_expresion .)
    equal           reduce using rule 27 (expr -> while_expresion .)
    loop            reduce using rule 27 (expr -> while_expresion .)
    cbracket        reduce using rule 27 (expr -> while_expresion .)
    then            reduce using rule 27 (expr -> while_expresion .)
    ccurly          reduce using rule 27 (expr -> while_expresion .)
    pool            reduce using rule 27 (expr -> while_expresion .)
    else            reduce using rule 27 (expr -> while_expresion .)
    obracket        reduce using rule 27 (expr -> while_expresion .)
    if              reduce using rule 27 (expr -> while_expresion .)
    let             reduce using rule 27 (expr -> while_expresion .)
    case            reduce using rule 27 (expr -> while_expresion .)
    ocurly          reduce using rule 27 (expr -> while_expresion .)
    not             reduce using rule 27 (expr -> while_expresion .)
    complement      reduce using rule 27 (expr -> while_expresion .)
    isvoid          reduce using rule 27 (expr -> while_expresion .)
    new             reduce using rule 27 (expr -> while_expresion .)
    number          reduce using rule 27 (expr -> while_expresion .)
    string          reduce using rule 27 (expr -> while_expresion .)
    true            reduce using rule 27 (expr -> while_expresion .)
    false           reduce using rule 27 (expr -> while_expresion .)
    fi              reduce using rule 27 (expr -> while_expresion .)


state 48

    (28) expr -> v_expr .
    (2) binary_operator -> v_expr . plus v_expr
    (3) binary_operator -> v_expr . minus v_expr
    (4) binary_operator -> v_expr . star v_expr
    (5) binary_operator -> v_expr . div v_expr
    (29) comparison_expresion -> v_expr . less v_expr
    (30) comparison_expresion -> v_expr . less_equal v_expr
    (31) comparison_expresion -> v_expr . equal v_expr

  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for star resolved as shift
  ! shift/reduce conflict for div resolved as shift
  ! shift/reduce conflict for less resolved as shift
  ! shift/reduce conflict for less_equal resolved as shift
  ! shift/reduce conflict for equal resolved as shift
    semicolon       reduce using rule 28 (expr -> v_expr .)
    idx             reduce using rule 28 (expr -> v_expr .)
    inx             reduce using rule 28 (expr -> v_expr .)
    of              reduce using rule 28 (expr -> v_expr .)
    loop            reduce using rule 28 (expr -> v_expr .)
    cbracket        reduce using rule 28 (expr -> v_expr .)
    then            reduce using rule 28 (expr -> v_expr .)
    ccurly          reduce using rule 28 (expr -> v_expr .)
    pool            reduce using rule 28 (expr -> v_expr .)
    else            reduce using rule 28 (expr -> v_expr .)
    obracket        reduce using rule 28 (expr -> v_expr .)
    if              reduce using rule 28 (expr -> v_expr .)
    let             reduce using rule 28 (expr -> v_expr .)
    case            reduce using rule 28 (expr -> v_expr .)
    ocurly          reduce using rule 28 (expr -> v_expr .)
    not             reduce using rule 28 (expr -> v_expr .)
    complement      reduce using rule 28 (expr -> v_expr .)
    isvoid          reduce using rule 28 (expr -> v_expr .)
    new             reduce using rule 28 (expr -> v_expr .)
    number          reduce using rule 28 (expr -> v_expr .)
    string          reduce using rule 28 (expr -> v_expr .)
    true            reduce using rule 28 (expr -> v_expr .)
    false           reduce using rule 28 (expr -> v_expr .)
    fi              reduce using rule 28 (expr -> v_expr .)
    plus            shift and go to state 86
    minus           shift and go to state 87
    star            shift and go to state 88
    div             shift and go to state 89
    less            shift and go to state 90
    less_equal      shift and go to state 91
    equal           shift and go to state 92

  ! plus            [ reduce using rule 28 (expr -> v_expr .) ]
  ! minus           [ reduce using rule 28 (expr -> v_expr .) ]
  ! star            [ reduce using rule 28 (expr -> v_expr .) ]
  ! div             [ reduce using rule 28 (expr -> v_expr .) ]
  ! less            [ reduce using rule 28 (expr -> v_expr .) ]
  ! less_equal      [ reduce using rule 28 (expr -> v_expr .) ]
  ! equal           [ reduce using rule 28 (expr -> v_expr .) ]


state 49

    (62) while_expresion -> while . v_expr loop expr pool
    (32) v_expr -> . conditional_expresion
    (33) v_expr -> . let_expresion
    (34) v_expr -> . case_expresion
    (35) v_expr -> . dispatch_expresion
    (36) v_expr -> . dispatch_instance
    (37) v_expr -> . block_expresion
    (38) v_expr -> . binary_operator
    (39) v_expr -> . neg
    (40) v_expr -> . compl
    (41) v_expr -> . is_void
    (42) v_expr -> . new_expresion
    (43) v_expr -> . obracket v_expr cbracket
    (44) v_expr -> . term
    (45) v_expr -> . comparison_expresion
    (60) conditional_expresion -> . if v_expr then expr else expr fi
    (67) let_expresion -> . let let_declr_list inx expr
    (63) case_expresion -> . case expr of case_list esac
    (71) dispatch_expresion -> . idx obracket dispatch_p_list cbracket
    (72) dispatch_instance -> . idx dot idx obracket dispatch_p_list cbracket
    (73) dispatch_instance -> . idx arrobe idx dot idx obracket dispatch_p_list cbracket
    (55) block_expresion -> . ocurly block_expr ccurly
    (2) binary_operator -> . v_expr plus v_expr
    (3) binary_operator -> . v_expr minus v_expr
    (4) binary_operator -> . v_expr star v_expr
    (5) binary_operator -> . v_expr div v_expr
    (9) neg -> . not idx
    (10) compl -> . complement idx
    (61) is_void -> . isvoid expr
    (15) new_expresion -> . new idx
    (46) term -> . var
    (47) term -> . num
    (48) term -> . str
    (49) term -> . bool
    (29) comparison_expresion -> . v_expr less v_expr
    (30) comparison_expresion -> . v_expr less_equal v_expr
    (31) comparison_expresion -> . v_expr equal v_expr
    (50) var -> . idx
    (51) num -> . number
    (52) str -> . string
    (53) bool -> . true
    (54) bool -> . false

    obracket        shift and go to state 61
    if              shift and go to state 64
    let             shift and go to state 65
    case            shift and go to state 66
    idx             shift and go to state 94
    ocurly          shift and go to state 67
    not             shift and go to state 68
    complement      shift and go to state 69
    isvoid          shift and go to state 70
    new             shift and go to state 71
    number          shift and go to state 76
    string          shift and go to state 77
    true            shift and go to state 78
    false           shift and go to state 79

    v_expr                         shift and go to state 93
    conditional_expresion          shift and go to state 50
    let_expresion                  shift and go to state 51
    case_expresion                 shift and go to state 52
    dispatch_expresion             shift and go to state 53
    dispatch_instance              shift and go to state 54
    block_expresion                shift and go to state 55
    binary_operator                shift and go to state 56
    neg                            shift and go to state 57
    compl                          shift and go to state 58
    is_void                        shift and go to state 59
    new_expresion                  shift and go to state 60
    term                           shift and go to state 62
    comparison_expresion           shift and go to state 63
    var                            shift and go to state 72
    num                            shift and go to state 73
    str                            shift and go to state 74
    bool                           shift and go to state 75

state 50

    (32) v_expr -> conditional_expresion .

    plus            reduce using rule 32 (v_expr -> conditional_expresion .)
    minus           reduce using rule 32 (v_expr -> conditional_expresion .)
    star            reduce using rule 32 (v_expr -> conditional_expresion .)
    div             reduce using rule 32 (v_expr -> conditional_expresion .)
    less            reduce using rule 32 (v_expr -> conditional_expresion .)
    less_equal      reduce using rule 32 (v_expr -> conditional_expresion .)
    equal           reduce using rule 32 (v_expr -> conditional_expresion .)
    semicolon       reduce using rule 32 (v_expr -> conditional_expresion .)
    idx             reduce using rule 32 (v_expr -> conditional_expresion .)
    inx             reduce using rule 32 (v_expr -> conditional_expresion .)
    loop            reduce using rule 32 (v_expr -> conditional_expresion .)
    cbracket        reduce using rule 32 (v_expr -> conditional_expresion .)
    then            reduce using rule 32 (v_expr -> conditional_expresion .)
    of              reduce using rule 32 (v_expr -> conditional_expresion .)
    ccurly          reduce using rule 32 (v_expr -> conditional_expresion .)
    pool            reduce using rule 32 (v_expr -> conditional_expresion .)
    else            reduce using rule 32 (v_expr -> conditional_expresion .)
    obracket        reduce using rule 32 (v_expr -> conditional_expresion .)
    if              reduce using rule 32 (v_expr -> conditional_expresion .)
    let             reduce using rule 32 (v_expr -> conditional_expresion .)
    case            reduce using rule 32 (v_expr -> conditional_expresion .)
    ocurly          reduce using rule 32 (v_expr -> conditional_expresion .)
    not             reduce using rule 32 (v_expr -> conditional_expresion .)
    complement      reduce using rule 32 (v_expr -> conditional_expresion .)
    isvoid          reduce using rule 32 (v_expr -> conditional_expresion .)
    new             reduce using rule 32 (v_expr -> conditional_expresion .)
    number          reduce using rule 32 (v_expr -> conditional_expresion .)
    string          reduce using rule 32 (v_expr -> conditional_expresion .)
    true            reduce using rule 32 (v_expr -> conditional_expresion .)
    false           reduce using rule 32 (v_expr -> conditional_expresion .)
    fi              reduce using rule 32 (v_expr -> conditional_expresion .)


state 51

    (33) v_expr -> let_expresion .

    plus            reduce using rule 33 (v_expr -> let_expresion .)
    minus           reduce using rule 33 (v_expr -> let_expresion .)
    star            reduce using rule 33 (v_expr -> let_expresion .)
    div             reduce using rule 33 (v_expr -> let_expresion .)
    less            reduce using rule 33 (v_expr -> let_expresion .)
    less_equal      reduce using rule 33 (v_expr -> let_expresion .)
    equal           reduce using rule 33 (v_expr -> let_expresion .)
    semicolon       reduce using rule 33 (v_expr -> let_expresion .)
    idx             reduce using rule 33 (v_expr -> let_expresion .)
    inx             reduce using rule 33 (v_expr -> let_expresion .)
    loop            reduce using rule 33 (v_expr -> let_expresion .)
    cbracket        reduce using rule 33 (v_expr -> let_expresion .)
    then            reduce using rule 33 (v_expr -> let_expresion .)
    of              reduce using rule 33 (v_expr -> let_expresion .)
    ccurly          reduce using rule 33 (v_expr -> let_expresion .)
    pool            reduce using rule 33 (v_expr -> let_expresion .)
    else            reduce using rule 33 (v_expr -> let_expresion .)
    obracket        reduce using rule 33 (v_expr -> let_expresion .)
    if              reduce using rule 33 (v_expr -> let_expresion .)
    let             reduce using rule 33 (v_expr -> let_expresion .)
    case            reduce using rule 33 (v_expr -> let_expresion .)
    ocurly          reduce using rule 33 (v_expr -> let_expresion .)
    not             reduce using rule 33 (v_expr -> let_expresion .)
    complement      reduce using rule 33 (v_expr -> let_expresion .)
    isvoid          reduce using rule 33 (v_expr -> let_expresion .)
    new             reduce using rule 33 (v_expr -> let_expresion .)
    number          reduce using rule 33 (v_expr -> let_expresion .)
    string          reduce using rule 33 (v_expr -> let_expresion .)
    true            reduce using rule 33 (v_expr -> let_expresion .)
    false           reduce using rule 33 (v_expr -> let_expresion .)
    fi              reduce using rule 33 (v_expr -> let_expresion .)


state 52

    (34) v_expr -> case_expresion .

    plus            reduce using rule 34 (v_expr -> case_expresion .)
    minus           reduce using rule 34 (v_expr -> case_expresion .)
    star            reduce using rule 34 (v_expr -> case_expresion .)
    div             reduce using rule 34 (v_expr -> case_expresion .)
    less            reduce using rule 34 (v_expr -> case_expresion .)
    less_equal      reduce using rule 34 (v_expr -> case_expresion .)
    equal           reduce using rule 34 (v_expr -> case_expresion .)
    semicolon       reduce using rule 34 (v_expr -> case_expresion .)
    idx             reduce using rule 34 (v_expr -> case_expresion .)
    inx             reduce using rule 34 (v_expr -> case_expresion .)
    loop            reduce using rule 34 (v_expr -> case_expresion .)
    cbracket        reduce using rule 34 (v_expr -> case_expresion .)
    then            reduce using rule 34 (v_expr -> case_expresion .)
    of              reduce using rule 34 (v_expr -> case_expresion .)
    ccurly          reduce using rule 34 (v_expr -> case_expresion .)
    pool            reduce using rule 34 (v_expr -> case_expresion .)
    else            reduce using rule 34 (v_expr -> case_expresion .)
    obracket        reduce using rule 34 (v_expr -> case_expresion .)
    if              reduce using rule 34 (v_expr -> case_expresion .)
    let             reduce using rule 34 (v_expr -> case_expresion .)
    case            reduce using rule 34 (v_expr -> case_expresion .)
    ocurly          reduce using rule 34 (v_expr -> case_expresion .)
    not             reduce using rule 34 (v_expr -> case_expresion .)
    complement      reduce using rule 34 (v_expr -> case_expresion .)
    isvoid          reduce using rule 34 (v_expr -> case_expresion .)
    new             reduce using rule 34 (v_expr -> case_expresion .)
    number          reduce using rule 34 (v_expr -> case_expresion .)
    string          reduce using rule 34 (v_expr -> case_expresion .)
    true            reduce using rule 34 (v_expr -> case_expresion .)
    false           reduce using rule 34 (v_expr -> case_expresion .)
    fi              reduce using rule 34 (v_expr -> case_expresion .)


state 53

    (35) v_expr -> dispatch_expresion .

    plus            reduce using rule 35 (v_expr -> dispatch_expresion .)
    minus           reduce using rule 35 (v_expr -> dispatch_expresion .)
    star            reduce using rule 35 (v_expr -> dispatch_expresion .)
    div             reduce using rule 35 (v_expr -> dispatch_expresion .)
    less            reduce using rule 35 (v_expr -> dispatch_expresion .)
    less_equal      reduce using rule 35 (v_expr -> dispatch_expresion .)
    equal           reduce using rule 35 (v_expr -> dispatch_expresion .)
    semicolon       reduce using rule 35 (v_expr -> dispatch_expresion .)
    idx             reduce using rule 35 (v_expr -> dispatch_expresion .)
    inx             reduce using rule 35 (v_expr -> dispatch_expresion .)
    loop            reduce using rule 35 (v_expr -> dispatch_expresion .)
    cbracket        reduce using rule 35 (v_expr -> dispatch_expresion .)
    then            reduce using rule 35 (v_expr -> dispatch_expresion .)
    of              reduce using rule 35 (v_expr -> dispatch_expresion .)
    ccurly          reduce using rule 35 (v_expr -> dispatch_expresion .)
    pool            reduce using rule 35 (v_expr -> dispatch_expresion .)
    else            reduce using rule 35 (v_expr -> dispatch_expresion .)
    obracket        reduce using rule 35 (v_expr -> dispatch_expresion .)
    if              reduce using rule 35 (v_expr -> dispatch_expresion .)
    let             reduce using rule 35 (v_expr -> dispatch_expresion .)
    case            reduce using rule 35 (v_expr -> dispatch_expresion .)
    ocurly          reduce using rule 35 (v_expr -> dispatch_expresion .)
    not             reduce using rule 35 (v_expr -> dispatch_expresion .)
    complement      reduce using rule 35 (v_expr -> dispatch_expresion .)
    isvoid          reduce using rule 35 (v_expr -> dispatch_expresion .)
    new             reduce using rule 35 (v_expr -> dispatch_expresion .)
    number          reduce using rule 35 (v_expr -> dispatch_expresion .)
    string          reduce using rule 35 (v_expr -> dispatch_expresion .)
    true            reduce using rule 35 (v_expr -> dispatch_expresion .)
    false           reduce using rule 35 (v_expr -> dispatch_expresion .)
    fi              reduce using rule 35 (v_expr -> dispatch_expresion .)


state 54

    (36) v_expr -> dispatch_instance .

    plus            reduce using rule 36 (v_expr -> dispatch_instance .)
    minus           reduce using rule 36 (v_expr -> dispatch_instance .)
    star            reduce using rule 36 (v_expr -> dispatch_instance .)
    div             reduce using rule 36 (v_expr -> dispatch_instance .)
    less            reduce using rule 36 (v_expr -> dispatch_instance .)
    less_equal      reduce using rule 36 (v_expr -> dispatch_instance .)
    equal           reduce using rule 36 (v_expr -> dispatch_instance .)
    semicolon       reduce using rule 36 (v_expr -> dispatch_instance .)
    idx             reduce using rule 36 (v_expr -> dispatch_instance .)
    inx             reduce using rule 36 (v_expr -> dispatch_instance .)
    loop            reduce using rule 36 (v_expr -> dispatch_instance .)
    cbracket        reduce using rule 36 (v_expr -> dispatch_instance .)
    then            reduce using rule 36 (v_expr -> dispatch_instance .)
    of              reduce using rule 36 (v_expr -> dispatch_instance .)
    ccurly          reduce using rule 36 (v_expr -> dispatch_instance .)
    pool            reduce using rule 36 (v_expr -> dispatch_instance .)
    else            reduce using rule 36 (v_expr -> dispatch_instance .)
    obracket        reduce using rule 36 (v_expr -> dispatch_instance .)
    if              reduce using rule 36 (v_expr -> dispatch_instance .)
    let             reduce using rule 36 (v_expr -> dispatch_instance .)
    case            reduce using rule 36 (v_expr -> dispatch_instance .)
    ocurly          reduce using rule 36 (v_expr -> dispatch_instance .)
    not             reduce using rule 36 (v_expr -> dispatch_instance .)
    complement      reduce using rule 36 (v_expr -> dispatch_instance .)
    isvoid          reduce using rule 36 (v_expr -> dispatch_instance .)
    new             reduce using rule 36 (v_expr -> dispatch_instance .)
    number          reduce using rule 36 (v_expr -> dispatch_instance .)
    string          reduce using rule 36 (v_expr -> dispatch_instance .)
    true            reduce using rule 36 (v_expr -> dispatch_instance .)
    false           reduce using rule 36 (v_expr -> dispatch_instance .)
    fi              reduce using rule 36 (v_expr -> dispatch_instance .)


state 55

    (37) v_expr -> block_expresion .

    plus            reduce using rule 37 (v_expr -> block_expresion .)
    minus           reduce using rule 37 (v_expr -> block_expresion .)
    star            reduce using rule 37 (v_expr -> block_expresion .)
    div             reduce using rule 37 (v_expr -> block_expresion .)
    less            reduce using rule 37 (v_expr -> block_expresion .)
    less_equal      reduce using rule 37 (v_expr -> block_expresion .)
    equal           reduce using rule 37 (v_expr -> block_expresion .)
    semicolon       reduce using rule 37 (v_expr -> block_expresion .)
    idx             reduce using rule 37 (v_expr -> block_expresion .)
    inx             reduce using rule 37 (v_expr -> block_expresion .)
    loop            reduce using rule 37 (v_expr -> block_expresion .)
    cbracket        reduce using rule 37 (v_expr -> block_expresion .)
    then            reduce using rule 37 (v_expr -> block_expresion .)
    of              reduce using rule 37 (v_expr -> block_expresion .)
    ccurly          reduce using rule 37 (v_expr -> block_expresion .)
    pool            reduce using rule 37 (v_expr -> block_expresion .)
    else            reduce using rule 37 (v_expr -> block_expresion .)
    obracket        reduce using rule 37 (v_expr -> block_expresion .)
    if              reduce using rule 37 (v_expr -> block_expresion .)
    let             reduce using rule 37 (v_expr -> block_expresion .)
    case            reduce using rule 37 (v_expr -> block_expresion .)
    ocurly          reduce using rule 37 (v_expr -> block_expresion .)
    not             reduce using rule 37 (v_expr -> block_expresion .)
    complement      reduce using rule 37 (v_expr -> block_expresion .)
    isvoid          reduce using rule 37 (v_expr -> block_expresion .)
    new             reduce using rule 37 (v_expr -> block_expresion .)
    number          reduce using rule 37 (v_expr -> block_expresion .)
    string          reduce using rule 37 (v_expr -> block_expresion .)
    true            reduce using rule 37 (v_expr -> block_expresion .)
    false           reduce using rule 37 (v_expr -> block_expresion .)
    fi              reduce using rule 37 (v_expr -> block_expresion .)


state 56

    (38) v_expr -> binary_operator .

    plus            reduce using rule 38 (v_expr -> binary_operator .)
    minus           reduce using rule 38 (v_expr -> binary_operator .)
    star            reduce using rule 38 (v_expr -> binary_operator .)
    div             reduce using rule 38 (v_expr -> binary_operator .)
    less            reduce using rule 38 (v_expr -> binary_operator .)
    less_equal      reduce using rule 38 (v_expr -> binary_operator .)
    equal           reduce using rule 38 (v_expr -> binary_operator .)
    semicolon       reduce using rule 38 (v_expr -> binary_operator .)
    idx             reduce using rule 38 (v_expr -> binary_operator .)
    inx             reduce using rule 38 (v_expr -> binary_operator .)
    loop            reduce using rule 38 (v_expr -> binary_operator .)
    cbracket        reduce using rule 38 (v_expr -> binary_operator .)
    then            reduce using rule 38 (v_expr -> binary_operator .)
    of              reduce using rule 38 (v_expr -> binary_operator .)
    ccurly          reduce using rule 38 (v_expr -> binary_operator .)
    pool            reduce using rule 38 (v_expr -> binary_operator .)
    else            reduce using rule 38 (v_expr -> binary_operator .)
    obracket        reduce using rule 38 (v_expr -> binary_operator .)
    if              reduce using rule 38 (v_expr -> binary_operator .)
    let             reduce using rule 38 (v_expr -> binary_operator .)
    case            reduce using rule 38 (v_expr -> binary_operator .)
    ocurly          reduce using rule 38 (v_expr -> binary_operator .)
    not             reduce using rule 38 (v_expr -> binary_operator .)
    complement      reduce using rule 38 (v_expr -> binary_operator .)
    isvoid          reduce using rule 38 (v_expr -> binary_operator .)
    new             reduce using rule 38 (v_expr -> binary_operator .)
    number          reduce using rule 38 (v_expr -> binary_operator .)
    string          reduce using rule 38 (v_expr -> binary_operator .)
    true            reduce using rule 38 (v_expr -> binary_operator .)
    false           reduce using rule 38 (v_expr -> binary_operator .)
    fi              reduce using rule 38 (v_expr -> binary_operator .)


state 57

    (39) v_expr -> neg .

    plus            reduce using rule 39 (v_expr -> neg .)
    minus           reduce using rule 39 (v_expr -> neg .)
    star            reduce using rule 39 (v_expr -> neg .)
    div             reduce using rule 39 (v_expr -> neg .)
    less            reduce using rule 39 (v_expr -> neg .)
    less_equal      reduce using rule 39 (v_expr -> neg .)
    equal           reduce using rule 39 (v_expr -> neg .)
    semicolon       reduce using rule 39 (v_expr -> neg .)
    idx             reduce using rule 39 (v_expr -> neg .)
    inx             reduce using rule 39 (v_expr -> neg .)
    loop            reduce using rule 39 (v_expr -> neg .)
    cbracket        reduce using rule 39 (v_expr -> neg .)
    then            reduce using rule 39 (v_expr -> neg .)
    of              reduce using rule 39 (v_expr -> neg .)
    ccurly          reduce using rule 39 (v_expr -> neg .)
    pool            reduce using rule 39 (v_expr -> neg .)
    else            reduce using rule 39 (v_expr -> neg .)
    obracket        reduce using rule 39 (v_expr -> neg .)
    if              reduce using rule 39 (v_expr -> neg .)
    let             reduce using rule 39 (v_expr -> neg .)
    case            reduce using rule 39 (v_expr -> neg .)
    ocurly          reduce using rule 39 (v_expr -> neg .)
    not             reduce using rule 39 (v_expr -> neg .)
    complement      reduce using rule 39 (v_expr -> neg .)
    isvoid          reduce using rule 39 (v_expr -> neg .)
    new             reduce using rule 39 (v_expr -> neg .)
    number          reduce using rule 39 (v_expr -> neg .)
    string          reduce using rule 39 (v_expr -> neg .)
    true            reduce using rule 39 (v_expr -> neg .)
    false           reduce using rule 39 (v_expr -> neg .)
    fi              reduce using rule 39 (v_expr -> neg .)


state 58

    (40) v_expr -> compl .

    plus            reduce using rule 40 (v_expr -> compl .)
    minus           reduce using rule 40 (v_expr -> compl .)
    star            reduce using rule 40 (v_expr -> compl .)
    div             reduce using rule 40 (v_expr -> compl .)
    less            reduce using rule 40 (v_expr -> compl .)
    less_equal      reduce using rule 40 (v_expr -> compl .)
    equal           reduce using rule 40 (v_expr -> compl .)
    semicolon       reduce using rule 40 (v_expr -> compl .)
    idx             reduce using rule 40 (v_expr -> compl .)
    inx             reduce using rule 40 (v_expr -> compl .)
    loop            reduce using rule 40 (v_expr -> compl .)
    cbracket        reduce using rule 40 (v_expr -> compl .)
    then            reduce using rule 40 (v_expr -> compl .)
    of              reduce using rule 40 (v_expr -> compl .)
    ccurly          reduce using rule 40 (v_expr -> compl .)
    pool            reduce using rule 40 (v_expr -> compl .)
    else            reduce using rule 40 (v_expr -> compl .)
    obracket        reduce using rule 40 (v_expr -> compl .)
    if              reduce using rule 40 (v_expr -> compl .)
    let             reduce using rule 40 (v_expr -> compl .)
    case            reduce using rule 40 (v_expr -> compl .)
    ocurly          reduce using rule 40 (v_expr -> compl .)
    not             reduce using rule 40 (v_expr -> compl .)
    complement      reduce using rule 40 (v_expr -> compl .)
    isvoid          reduce using rule 40 (v_expr -> compl .)
    new             reduce using rule 40 (v_expr -> compl .)
    number          reduce using rule 40 (v_expr -> compl .)
    string          reduce using rule 40 (v_expr -> compl .)
    true            reduce using rule 40 (v_expr -> compl .)
    false           reduce using rule 40 (v_expr -> compl .)
    fi              reduce using rule 40 (v_expr -> compl .)


state 59

    (41) v_expr -> is_void .

    plus            reduce using rule 41 (v_expr -> is_void .)
    minus           reduce using rule 41 (v_expr -> is_void .)
    star            reduce using rule 41 (v_expr -> is_void .)
    div             reduce using rule 41 (v_expr -> is_void .)
    less            reduce using rule 41 (v_expr -> is_void .)
    less_equal      reduce using rule 41 (v_expr -> is_void .)
    equal           reduce using rule 41 (v_expr -> is_void .)
    semicolon       reduce using rule 41 (v_expr -> is_void .)
    idx             reduce using rule 41 (v_expr -> is_void .)
    inx             reduce using rule 41 (v_expr -> is_void .)
    loop            reduce using rule 41 (v_expr -> is_void .)
    cbracket        reduce using rule 41 (v_expr -> is_void .)
    then            reduce using rule 41 (v_expr -> is_void .)
    of              reduce using rule 41 (v_expr -> is_void .)
    ccurly          reduce using rule 41 (v_expr -> is_void .)
    pool            reduce using rule 41 (v_expr -> is_void .)
    else            reduce using rule 41 (v_expr -> is_void .)
    obracket        reduce using rule 41 (v_expr -> is_void .)
    if              reduce using rule 41 (v_expr -> is_void .)
    let             reduce using rule 41 (v_expr -> is_void .)
    case            reduce using rule 41 (v_expr -> is_void .)
    ocurly          reduce using rule 41 (v_expr -> is_void .)
    not             reduce using rule 41 (v_expr -> is_void .)
    complement      reduce using rule 41 (v_expr -> is_void .)
    isvoid          reduce using rule 41 (v_expr -> is_void .)
    new             reduce using rule 41 (v_expr -> is_void .)
    number          reduce using rule 41 (v_expr -> is_void .)
    string          reduce using rule 41 (v_expr -> is_void .)
    true            reduce using rule 41 (v_expr -> is_void .)
    false           reduce using rule 41 (v_expr -> is_void .)
    fi              reduce using rule 41 (v_expr -> is_void .)


state 60

    (42) v_expr -> new_expresion .

    plus            reduce using rule 42 (v_expr -> new_expresion .)
    minus           reduce using rule 42 (v_expr -> new_expresion .)
    star            reduce using rule 42 (v_expr -> new_expresion .)
    div             reduce using rule 42 (v_expr -> new_expresion .)
    less            reduce using rule 42 (v_expr -> new_expresion .)
    less_equal      reduce using rule 42 (v_expr -> new_expresion .)
    equal           reduce using rule 42 (v_expr -> new_expresion .)
    semicolon       reduce using rule 42 (v_expr -> new_expresion .)
    idx             reduce using rule 42 (v_expr -> new_expresion .)
    inx             reduce using rule 42 (v_expr -> new_expresion .)
    loop            reduce using rule 42 (v_expr -> new_expresion .)
    cbracket        reduce using rule 42 (v_expr -> new_expresion .)
    then            reduce using rule 42 (v_expr -> new_expresion .)
    of              reduce using rule 42 (v_expr -> new_expresion .)
    ccurly          reduce using rule 42 (v_expr -> new_expresion .)
    pool            reduce using rule 42 (v_expr -> new_expresion .)
    else            reduce using rule 42 (v_expr -> new_expresion .)
    obracket        reduce using rule 42 (v_expr -> new_expresion .)
    if              reduce using rule 42 (v_expr -> new_expresion .)
    let             reduce using rule 42 (v_expr -> new_expresion .)
    case            reduce using rule 42 (v_expr -> new_expresion .)
    ocurly          reduce using rule 42 (v_expr -> new_expresion .)
    not             reduce using rule 42 (v_expr -> new_expresion .)
    complement      reduce using rule 42 (v_expr -> new_expresion .)
    isvoid          reduce using rule 42 (v_expr -> new_expresion .)
    new             reduce using rule 42 (v_expr -> new_expresion .)
    number          reduce using rule 42 (v_expr -> new_expresion .)
    string          reduce using rule 42 (v_expr -> new_expresion .)
    true            reduce using rule 42 (v_expr -> new_expresion .)
    false           reduce using rule 42 (v_expr -> new_expresion .)
    fi              reduce using rule 42 (v_expr -> new_expresion .)


state 61

    (43) v_expr -> obracket . v_expr cbracket
    (32) v_expr -> . conditional_expresion
    (33) v_expr -> . let_expresion
    (34) v_expr -> . case_expresion
    (35) v_expr -> . dispatch_expresion
    (36) v_expr -> . dispatch_instance
    (37) v_expr -> . block_expresion
    (38) v_expr -> . binary_operator
    (39) v_expr -> . neg
    (40) v_expr -> . compl
    (41) v_expr -> . is_void
    (42) v_expr -> . new_expresion
    (43) v_expr -> . obracket v_expr cbracket
    (44) v_expr -> . term
    (45) v_expr -> . comparison_expresion
    (60) conditional_expresion -> . if v_expr then expr else expr fi
    (67) let_expresion -> . let let_declr_list inx expr
    (63) case_expresion -> . case expr of case_list esac
    (71) dispatch_expresion -> . idx obracket dispatch_p_list cbracket
    (72) dispatch_instance -> . idx dot idx obracket dispatch_p_list cbracket
    (73) dispatch_instance -> . idx arrobe idx dot idx obracket dispatch_p_list cbracket
    (55) block_expresion -> . ocurly block_expr ccurly
    (2) binary_operator -> . v_expr plus v_expr
    (3) binary_operator -> . v_expr minus v_expr
    (4) binary_operator -> . v_expr star v_expr
    (5) binary_operator -> . v_expr div v_expr
    (9) neg -> . not idx
    (10) compl -> . complement idx
    (61) is_void -> . isvoid expr
    (15) new_expresion -> . new idx
    (46) term -> . var
    (47) term -> . num
    (48) term -> . str
    (49) term -> . bool
    (29) comparison_expresion -> . v_expr less v_expr
    (30) comparison_expresion -> . v_expr less_equal v_expr
    (31) comparison_expresion -> . v_expr equal v_expr
    (50) var -> . idx
    (51) num -> . number
    (52) str -> . string
    (53) bool -> . true
    (54) bool -> . false

    obracket        shift and go to state 61
    if              shift and go to state 64
    let             shift and go to state 65
    case            shift and go to state 66
    idx             shift and go to state 94
    ocurly          shift and go to state 67
    not             shift and go to state 68
    complement      shift and go to state 69
    isvoid          shift and go to state 70
    new             shift and go to state 71
    number          shift and go to state 76
    string          shift and go to state 77
    true            shift and go to state 78
    false           shift and go to state 79

    v_expr                         shift and go to state 95
    conditional_expresion          shift and go to state 50
    let_expresion                  shift and go to state 51
    case_expresion                 shift and go to state 52
    dispatch_expresion             shift and go to state 53
    dispatch_instance              shift and go to state 54
    block_expresion                shift and go to state 55
    binary_operator                shift and go to state 56
    neg                            shift and go to state 57
    compl                          shift and go to state 58
    is_void                        shift and go to state 59
    new_expresion                  shift and go to state 60
    term                           shift and go to state 62
    comparison_expresion           shift and go to state 63
    var                            shift and go to state 72
    num                            shift and go to state 73
    str                            shift and go to state 74
    bool                           shift and go to state 75

state 62

    (44) v_expr -> term .

    plus            reduce using rule 44 (v_expr -> term .)
    minus           reduce using rule 44 (v_expr -> term .)
    star            reduce using rule 44 (v_expr -> term .)
    div             reduce using rule 44 (v_expr -> term .)
    less            reduce using rule 44 (v_expr -> term .)
    less_equal      reduce using rule 44 (v_expr -> term .)
    equal           reduce using rule 44 (v_expr -> term .)
    semicolon       reduce using rule 44 (v_expr -> term .)
    idx             reduce using rule 44 (v_expr -> term .)
    inx             reduce using rule 44 (v_expr -> term .)
    loop            reduce using rule 44 (v_expr -> term .)
    cbracket        reduce using rule 44 (v_expr -> term .)
    then            reduce using rule 44 (v_expr -> term .)
    of              reduce using rule 44 (v_expr -> term .)
    ccurly          reduce using rule 44 (v_expr -> term .)
    pool            reduce using rule 44 (v_expr -> term .)
    else            reduce using rule 44 (v_expr -> term .)
    obracket        reduce using rule 44 (v_expr -> term .)
    if              reduce using rule 44 (v_expr -> term .)
    let             reduce using rule 44 (v_expr -> term .)
    case            reduce using rule 44 (v_expr -> term .)
    ocurly          reduce using rule 44 (v_expr -> term .)
    not             reduce using rule 44 (v_expr -> term .)
    complement      reduce using rule 44 (v_expr -> term .)
    isvoid          reduce using rule 44 (v_expr -> term .)
    new             reduce using rule 44 (v_expr -> term .)
    number          reduce using rule 44 (v_expr -> term .)
    string          reduce using rule 44 (v_expr -> term .)
    true            reduce using rule 44 (v_expr -> term .)
    false           reduce using rule 44 (v_expr -> term .)
    fi              reduce using rule 44 (v_expr -> term .)


state 63

    (45) v_expr -> comparison_expresion .

    plus            reduce using rule 45 (v_expr -> comparison_expresion .)
    minus           reduce using rule 45 (v_expr -> comparison_expresion .)
    star            reduce using rule 45 (v_expr -> comparison_expresion .)
    div             reduce using rule 45 (v_expr -> comparison_expresion .)
    less            reduce using rule 45 (v_expr -> comparison_expresion .)
    less_equal      reduce using rule 45 (v_expr -> comparison_expresion .)
    equal           reduce using rule 45 (v_expr -> comparison_expresion .)
    semicolon       reduce using rule 45 (v_expr -> comparison_expresion .)
    idx             reduce using rule 45 (v_expr -> comparison_expresion .)
    inx             reduce using rule 45 (v_expr -> comparison_expresion .)
    loop            reduce using rule 45 (v_expr -> comparison_expresion .)
    cbracket        reduce using rule 45 (v_expr -> comparison_expresion .)
    then            reduce using rule 45 (v_expr -> comparison_expresion .)
    of              reduce using rule 45 (v_expr -> comparison_expresion .)
    ccurly          reduce using rule 45 (v_expr -> comparison_expresion .)
    pool            reduce using rule 45 (v_expr -> comparison_expresion .)
    else            reduce using rule 45 (v_expr -> comparison_expresion .)
    obracket        reduce using rule 45 (v_expr -> comparison_expresion .)
    if              reduce using rule 45 (v_expr -> comparison_expresion .)
    let             reduce using rule 45 (v_expr -> comparison_expresion .)
    case            reduce using rule 45 (v_expr -> comparison_expresion .)
    ocurly          reduce using rule 45 (v_expr -> comparison_expresion .)
    not             reduce using rule 45 (v_expr -> comparison_expresion .)
    complement      reduce using rule 45 (v_expr -> comparison_expresion .)
    isvoid          reduce using rule 45 (v_expr -> comparison_expresion .)
    new             reduce using rule 45 (v_expr -> comparison_expresion .)
    number          reduce using rule 45 (v_expr -> comparison_expresion .)
    string          reduce using rule 45 (v_expr -> comparison_expresion .)
    true            reduce using rule 45 (v_expr -> comparison_expresion .)
    false           reduce using rule 45 (v_expr -> comparison_expresion .)
    fi              reduce using rule 45 (v_expr -> comparison_expresion .)


state 64

    (60) conditional_expresion -> if . v_expr then expr else expr fi
    (32) v_expr -> . conditional_expresion
    (33) v_expr -> . let_expresion
    (34) v_expr -> . case_expresion
    (35) v_expr -> . dispatch_expresion
    (36) v_expr -> . dispatch_instance
    (37) v_expr -> . block_expresion
    (38) v_expr -> . binary_operator
    (39) v_expr -> . neg
    (40) v_expr -> . compl
    (41) v_expr -> . is_void
    (42) v_expr -> . new_expresion
    (43) v_expr -> . obracket v_expr cbracket
    (44) v_expr -> . term
    (45) v_expr -> . comparison_expresion
    (60) conditional_expresion -> . if v_expr then expr else expr fi
    (67) let_expresion -> . let let_declr_list inx expr
    (63) case_expresion -> . case expr of case_list esac
    (71) dispatch_expresion -> . idx obracket dispatch_p_list cbracket
    (72) dispatch_instance -> . idx dot idx obracket dispatch_p_list cbracket
    (73) dispatch_instance -> . idx arrobe idx dot idx obracket dispatch_p_list cbracket
    (55) block_expresion -> . ocurly block_expr ccurly
    (2) binary_operator -> . v_expr plus v_expr
    (3) binary_operator -> . v_expr minus v_expr
    (4) binary_operator -> . v_expr star v_expr
    (5) binary_operator -> . v_expr div v_expr
    (9) neg -> . not idx
    (10) compl -> . complement idx
    (61) is_void -> . isvoid expr
    (15) new_expresion -> . new idx
    (46) term -> . var
    (47) term -> . num
    (48) term -> . str
    (49) term -> . bool
    (29) comparison_expresion -> . v_expr less v_expr
    (30) comparison_expresion -> . v_expr less_equal v_expr
    (31) comparison_expresion -> . v_expr equal v_expr
    (50) var -> . idx
    (51) num -> . number
    (52) str -> . string
    (53) bool -> . true
    (54) bool -> . false

    obracket        shift and go to state 61
    if              shift and go to state 64
    let             shift and go to state 65
    case            shift and go to state 66
    idx             shift and go to state 94
    ocurly          shift and go to state 67
    not             shift and go to state 68
    complement      shift and go to state 69
    isvoid          shift and go to state 70
    new             shift and go to state 71
    number          shift and go to state 76
    string          shift and go to state 77
    true            shift and go to state 78
    false           shift and go to state 79

    v_expr                         shift and go to state 96
    conditional_expresion          shift and go to state 50
    let_expresion                  shift and go to state 51
    case_expresion                 shift and go to state 52
    dispatch_expresion             shift and go to state 53
    dispatch_instance              shift and go to state 54
    block_expresion                shift and go to state 55
    binary_operator                shift and go to state 56
    neg                            shift and go to state 57
    compl                          shift and go to state 58
    is_void                        shift and go to state 59
    new_expresion                  shift and go to state 60
    term                           shift and go to state 62
    comparison_expresion           shift and go to state 63
    var                            shift and go to state 72
    num                            shift and go to state 73
    str                            shift and go to state 74
    bool                           shift and go to state 75

state 65

    (67) let_expresion -> let . let_declr_list inx expr
    (68) let_declr_list -> . declare_expresion let_declr_list_a
    (12) declare_expresion -> . idx doubledot idx assign expr
    (13) declare_expresion -> . idx doubledot idx

    idx             shift and go to state 99

    let_declr_list                 shift and go to state 97
    declare_expresion              shift and go to state 98

state 66

    (63) case_expresion -> case . expr of case_list esac
    (26) expr -> . assign_expresion
    (27) expr -> . while_expresion
    (28) expr -> . v_expr
    (11) assign_expresion -> . idx assign expr
    (62) while_expresion -> . while v_expr loop expr pool
    (32) v_expr -> . conditional_expresion
    (33) v_expr -> . let_expresion
    (34) v_expr -> . case_expresion
    (35) v_expr -> . dispatch_expresion
    (36) v_expr -> . dispatch_instance
    (37) v_expr -> . block_expresion
    (38) v_expr -> . binary_operator
    (39) v_expr -> . neg
    (40) v_expr -> . compl
    (41) v_expr -> . is_void
    (42) v_expr -> . new_expresion
    (43) v_expr -> . obracket v_expr cbracket
    (44) v_expr -> . term
    (45) v_expr -> . comparison_expresion
    (60) conditional_expresion -> . if v_expr then expr else expr fi
    (67) let_expresion -> . let let_declr_list inx expr
    (63) case_expresion -> . case expr of case_list esac
    (71) dispatch_expresion -> . idx obracket dispatch_p_list cbracket
    (72) dispatch_instance -> . idx dot idx obracket dispatch_p_list cbracket
    (73) dispatch_instance -> . idx arrobe idx dot idx obracket dispatch_p_list cbracket
    (55) block_expresion -> . ocurly block_expr ccurly
    (2) binary_operator -> . v_expr plus v_expr
    (3) binary_operator -> . v_expr minus v_expr
    (4) binary_operator -> . v_expr star v_expr
    (5) binary_operator -> . v_expr div v_expr
    (9) neg -> . not idx
    (10) compl -> . complement idx
    (61) is_void -> . isvoid expr
    (15) new_expresion -> . new idx
    (46) term -> . var
    (47) term -> . num
    (48) term -> . str
    (49) term -> . bool
    (29) comparison_expresion -> . v_expr less v_expr
    (30) comparison_expresion -> . v_expr less_equal v_expr
    (31) comparison_expresion -> . v_expr equal v_expr
    (50) var -> . idx
    (51) num -> . number
    (52) str -> . string
    (53) bool -> . true
    (54) bool -> . false

    idx             shift and go to state 44
    while           shift and go to state 49
    obracket        shift and go to state 61
    if              shift and go to state 64
    let             shift and go to state 65
    case            shift and go to state 66
    ocurly          shift and go to state 67
    not             shift and go to state 68
    complement      shift and go to state 69
    isvoid          shift and go to state 70
    new             shift and go to state 71
    number          shift and go to state 76
    string          shift and go to state 77
    true            shift and go to state 78
    false           shift and go to state 79

    expr                           shift and go to state 100
    assign_expresion               shift and go to state 46
    while_expresion                shift and go to state 47
    v_expr                         shift and go to state 48
    conditional_expresion          shift and go to state 50
    let_expresion                  shift and go to state 51
    case_expresion                 shift and go to state 52
    dispatch_expresion             shift and go to state 53
    dispatch_instance              shift and go to state 54
    block_expresion                shift and go to state 55
    binary_operator                shift and go to state 56
    neg                            shift and go to state 57
    compl                          shift and go to state 58
    is_void                        shift and go to state 59
    new_expresion                  shift and go to state 60
    term                           shift and go to state 62
    comparison_expresion           shift and go to state 63
    var                            shift and go to state 72
    num                            shift and go to state 73
    str                            shift and go to state 74
    bool                           shift and go to state 75

state 67

    (55) block_expresion -> ocurly . block_expr ccurly
    (56) block_expr -> . expr semicolon block_expr_a
    (26) expr -> . assign_expresion
    (27) expr -> . while_expresion
    (28) expr -> . v_expr
    (11) assign_expresion -> . idx assign expr
    (62) while_expresion -> . while v_expr loop expr pool
    (32) v_expr -> . conditional_expresion
    (33) v_expr -> . let_expresion
    (34) v_expr -> . case_expresion
    (35) v_expr -> . dispatch_expresion
    (36) v_expr -> . dispatch_instance
    (37) v_expr -> . block_expresion
    (38) v_expr -> . binary_operator
    (39) v_expr -> . neg
    (40) v_expr -> . compl
    (41) v_expr -> . is_void
    (42) v_expr -> . new_expresion
    (43) v_expr -> . obracket v_expr cbracket
    (44) v_expr -> . term
    (45) v_expr -> . comparison_expresion
    (60) conditional_expresion -> . if v_expr then expr else expr fi
    (67) let_expresion -> . let let_declr_list inx expr
    (63) case_expresion -> . case expr of case_list esac
    (71) dispatch_expresion -> . idx obracket dispatch_p_list cbracket
    (72) dispatch_instance -> . idx dot idx obracket dispatch_p_list cbracket
    (73) dispatch_instance -> . idx arrobe idx dot idx obracket dispatch_p_list cbracket
    (55) block_expresion -> . ocurly block_expr ccurly
    (2) binary_operator -> . v_expr plus v_expr
    (3) binary_operator -> . v_expr minus v_expr
    (4) binary_operator -> . v_expr star v_expr
    (5) binary_operator -> . v_expr div v_expr
    (9) neg -> . not idx
    (10) compl -> . complement idx
    (61) is_void -> . isvoid expr
    (15) new_expresion -> . new idx
    (46) term -> . var
    (47) term -> . num
    (48) term -> . str
    (49) term -> . bool
    (29) comparison_expresion -> . v_expr less v_expr
    (30) comparison_expresion -> . v_expr less_equal v_expr
    (31) comparison_expresion -> . v_expr equal v_expr
    (50) var -> . idx
    (51) num -> . number
    (52) str -> . string
    (53) bool -> . true
    (54) bool -> . false

    idx             shift and go to state 44
    while           shift and go to state 49
    obracket        shift and go to state 61
    if              shift and go to state 64
    let             shift and go to state 65
    case            shift and go to state 66
    ocurly          shift and go to state 67
    not             shift and go to state 68
    complement      shift and go to state 69
    isvoid          shift and go to state 70
    new             shift and go to state 71
    number          shift and go to state 76
    string          shift and go to state 77
    true            shift and go to state 78
    false           shift and go to state 79

    block_expr                     shift and go to state 101
    expr                           shift and go to state 102
    assign_expresion               shift and go to state 46
    while_expresion                shift and go to state 47
    v_expr                         shift and go to state 48
    conditional_expresion          shift and go to state 50
    let_expresion                  shift and go to state 51
    case_expresion                 shift and go to state 52
    dispatch_expresion             shift and go to state 53
    dispatch_instance              shift and go to state 54
    block_expresion                shift and go to state 55
    binary_operator                shift and go to state 56
    neg                            shift and go to state 57
    compl                          shift and go to state 58
    is_void                        shift and go to state 59
    new_expresion                  shift and go to state 60
    term                           shift and go to state 62
    comparison_expresion           shift and go to state 63
    var                            shift and go to state 72
    num                            shift and go to state 73
    str                            shift and go to state 74
    bool                           shift and go to state 75

state 68

    (9) neg -> not . idx

    idx             shift and go to state 103


state 69

    (10) compl -> complement . idx

    idx             shift and go to state 104


state 70

    (61) is_void -> isvoid . expr
    (26) expr -> . assign_expresion
    (27) expr -> . while_expresion
    (28) expr -> . v_expr
    (11) assign_expresion -> . idx assign expr
    (62) while_expresion -> . while v_expr loop expr pool
    (32) v_expr -> . conditional_expresion
    (33) v_expr -> . let_expresion
    (34) v_expr -> . case_expresion
    (35) v_expr -> . dispatch_expresion
    (36) v_expr -> . dispatch_instance
    (37) v_expr -> . block_expresion
    (38) v_expr -> . binary_operator
    (39) v_expr -> . neg
    (40) v_expr -> . compl
    (41) v_expr -> . is_void
    (42) v_expr -> . new_expresion
    (43) v_expr -> . obracket v_expr cbracket
    (44) v_expr -> . term
    (45) v_expr -> . comparison_expresion
    (60) conditional_expresion -> . if v_expr then expr else expr fi
    (67) let_expresion -> . let let_declr_list inx expr
    (63) case_expresion -> . case expr of case_list esac
    (71) dispatch_expresion -> . idx obracket dispatch_p_list cbracket
    (72) dispatch_instance -> . idx dot idx obracket dispatch_p_list cbracket
    (73) dispatch_instance -> . idx arrobe idx dot idx obracket dispatch_p_list cbracket
    (55) block_expresion -> . ocurly block_expr ccurly
    (2) binary_operator -> . v_expr plus v_expr
    (3) binary_operator -> . v_expr minus v_expr
    (4) binary_operator -> . v_expr star v_expr
    (5) binary_operator -> . v_expr div v_expr
    (9) neg -> . not idx
    (10) compl -> . complement idx
    (61) is_void -> . isvoid expr
    (15) new_expresion -> . new idx
    (46) term -> . var
    (47) term -> . num
    (48) term -> . str
    (49) term -> . bool
    (29) comparison_expresion -> . v_expr less v_expr
    (30) comparison_expresion -> . v_expr less_equal v_expr
    (31) comparison_expresion -> . v_expr equal v_expr
    (50) var -> . idx
    (51) num -> . number
    (52) str -> . string
    (53) bool -> . true
    (54) bool -> . false

    idx             shift and go to state 44
    while           shift and go to state 49
    obracket        shift and go to state 61
    if              shift and go to state 64
    let             shift and go to state 65
    case            shift and go to state 66
    ocurly          shift and go to state 67
    not             shift and go to state 68
    complement      shift and go to state 69
    isvoid          shift and go to state 70
    new             shift and go to state 71
    number          shift and go to state 76
    string          shift and go to state 77
    true            shift and go to state 78
    false           shift and go to state 79

    expr                           shift and go to state 105
    assign_expresion               shift and go to state 46
    while_expresion                shift and go to state 47
    v_expr                         shift and go to state 48
    conditional_expresion          shift and go to state 50
    let_expresion                  shift and go to state 51
    case_expresion                 shift and go to state 52
    dispatch_expresion             shift and go to state 53
    dispatch_instance              shift and go to state 54
    block_expresion                shift and go to state 55
    binary_operator                shift and go to state 56
    neg                            shift and go to state 57
    compl                          shift and go to state 58
    is_void                        shift and go to state 59
    new_expresion                  shift and go to state 60
    term                           shift and go to state 62
    comparison_expresion           shift and go to state 63
    var                            shift and go to state 72
    num                            shift and go to state 73
    str                            shift and go to state 74
    bool                           shift and go to state 75

state 71

    (15) new_expresion -> new . idx

    idx             shift and go to state 106


state 72

    (46) term -> var .

    plus            reduce using rule 46 (term -> var .)
    minus           reduce using rule 46 (term -> var .)
    star            reduce using rule 46 (term -> var .)
    div             reduce using rule 46 (term -> var .)
    less            reduce using rule 46 (term -> var .)
    less_equal      reduce using rule 46 (term -> var .)
    equal           reduce using rule 46 (term -> var .)
    semicolon       reduce using rule 46 (term -> var .)
    idx             reduce using rule 46 (term -> var .)
    inx             reduce using rule 46 (term -> var .)
    loop            reduce using rule 46 (term -> var .)
    cbracket        reduce using rule 46 (term -> var .)
    then            reduce using rule 46 (term -> var .)
    of              reduce using rule 46 (term -> var .)
    ccurly          reduce using rule 46 (term -> var .)
    pool            reduce using rule 46 (term -> var .)
    else            reduce using rule 46 (term -> var .)
    obracket        reduce using rule 46 (term -> var .)
    if              reduce using rule 46 (term -> var .)
    let             reduce using rule 46 (term -> var .)
    case            reduce using rule 46 (term -> var .)
    ocurly          reduce using rule 46 (term -> var .)
    not             reduce using rule 46 (term -> var .)
    complement      reduce using rule 46 (term -> var .)
    isvoid          reduce using rule 46 (term -> var .)
    new             reduce using rule 46 (term -> var .)
    number          reduce using rule 46 (term -> var .)
    string          reduce using rule 46 (term -> var .)
    true            reduce using rule 46 (term -> var .)
    false           reduce using rule 46 (term -> var .)
    fi              reduce using rule 46 (term -> var .)


state 73

    (47) term -> num .

    plus            reduce using rule 47 (term -> num .)
    minus           reduce using rule 47 (term -> num .)
    star            reduce using rule 47 (term -> num .)
    div             reduce using rule 47 (term -> num .)
    less            reduce using rule 47 (term -> num .)
    less_equal      reduce using rule 47 (term -> num .)
    equal           reduce using rule 47 (term -> num .)
    semicolon       reduce using rule 47 (term -> num .)
    idx             reduce using rule 47 (term -> num .)
    inx             reduce using rule 47 (term -> num .)
    loop            reduce using rule 47 (term -> num .)
    cbracket        reduce using rule 47 (term -> num .)
    then            reduce using rule 47 (term -> num .)
    of              reduce using rule 47 (term -> num .)
    ccurly          reduce using rule 47 (term -> num .)
    pool            reduce using rule 47 (term -> num .)
    else            reduce using rule 47 (term -> num .)
    obracket        reduce using rule 47 (term -> num .)
    if              reduce using rule 47 (term -> num .)
    let             reduce using rule 47 (term -> num .)
    case            reduce using rule 47 (term -> num .)
    ocurly          reduce using rule 47 (term -> num .)
    not             reduce using rule 47 (term -> num .)
    complement      reduce using rule 47 (term -> num .)
    isvoid          reduce using rule 47 (term -> num .)
    new             reduce using rule 47 (term -> num .)
    number          reduce using rule 47 (term -> num .)
    string          reduce using rule 47 (term -> num .)
    true            reduce using rule 47 (term -> num .)
    false           reduce using rule 47 (term -> num .)
    fi              reduce using rule 47 (term -> num .)


state 74

    (48) term -> str .

    plus            reduce using rule 48 (term -> str .)
    minus           reduce using rule 48 (term -> str .)
    star            reduce using rule 48 (term -> str .)
    div             reduce using rule 48 (term -> str .)
    less            reduce using rule 48 (term -> str .)
    less_equal      reduce using rule 48 (term -> str .)
    equal           reduce using rule 48 (term -> str .)
    semicolon       reduce using rule 48 (term -> str .)
    idx             reduce using rule 48 (term -> str .)
    inx             reduce using rule 48 (term -> str .)
    loop            reduce using rule 48 (term -> str .)
    cbracket        reduce using rule 48 (term -> str .)
    then            reduce using rule 48 (term -> str .)
    of              reduce using rule 48 (term -> str .)
    ccurly          reduce using rule 48 (term -> str .)
    pool            reduce using rule 48 (term -> str .)
    else            reduce using rule 48 (term -> str .)
    obracket        reduce using rule 48 (term -> str .)
    if              reduce using rule 48 (term -> str .)
    let             reduce using rule 48 (term -> str .)
    case            reduce using rule 48 (term -> str .)
    ocurly          reduce using rule 48 (term -> str .)
    not             reduce using rule 48 (term -> str .)
    complement      reduce using rule 48 (term -> str .)
    isvoid          reduce using rule 48 (term -> str .)
    new             reduce using rule 48 (term -> str .)
    number          reduce using rule 48 (term -> str .)
    string          reduce using rule 48 (term -> str .)
    true            reduce using rule 48 (term -> str .)
    false           reduce using rule 48 (term -> str .)
    fi              reduce using rule 48 (term -> str .)


state 75

    (49) term -> bool .

    plus            reduce using rule 49 (term -> bool .)
    minus           reduce using rule 49 (term -> bool .)
    star            reduce using rule 49 (term -> bool .)
    div             reduce using rule 49 (term -> bool .)
    less            reduce using rule 49 (term -> bool .)
    less_equal      reduce using rule 49 (term -> bool .)
    equal           reduce using rule 49 (term -> bool .)
    semicolon       reduce using rule 49 (term -> bool .)
    idx             reduce using rule 49 (term -> bool .)
    inx             reduce using rule 49 (term -> bool .)
    loop            reduce using rule 49 (term -> bool .)
    cbracket        reduce using rule 49 (term -> bool .)
    then            reduce using rule 49 (term -> bool .)
    of              reduce using rule 49 (term -> bool .)
    ccurly          reduce using rule 49 (term -> bool .)
    pool            reduce using rule 49 (term -> bool .)
    else            reduce using rule 49 (term -> bool .)
    obracket        reduce using rule 49 (term -> bool .)
    if              reduce using rule 49 (term -> bool .)
    let             reduce using rule 49 (term -> bool .)
    case            reduce using rule 49 (term -> bool .)
    ocurly          reduce using rule 49 (term -> bool .)
    not             reduce using rule 49 (term -> bool .)
    complement      reduce using rule 49 (term -> bool .)
    isvoid          reduce using rule 49 (term -> bool .)
    new             reduce using rule 49 (term -> bool .)
    number          reduce using rule 49 (term -> bool .)
    string          reduce using rule 49 (term -> bool .)
    true            reduce using rule 49 (term -> bool .)
    false           reduce using rule 49 (term -> bool .)
    fi              reduce using rule 49 (term -> bool .)


state 76

    (51) num -> number .

    plus            reduce using rule 51 (num -> number .)
    minus           reduce using rule 51 (num -> number .)
    star            reduce using rule 51 (num -> number .)
    div             reduce using rule 51 (num -> number .)
    less            reduce using rule 51 (num -> number .)
    less_equal      reduce using rule 51 (num -> number .)
    equal           reduce using rule 51 (num -> number .)
    semicolon       reduce using rule 51 (num -> number .)
    idx             reduce using rule 51 (num -> number .)
    inx             reduce using rule 51 (num -> number .)
    loop            reduce using rule 51 (num -> number .)
    cbracket        reduce using rule 51 (num -> number .)
    then            reduce using rule 51 (num -> number .)
    of              reduce using rule 51 (num -> number .)
    ccurly          reduce using rule 51 (num -> number .)
    pool            reduce using rule 51 (num -> number .)
    else            reduce using rule 51 (num -> number .)
    obracket        reduce using rule 51 (num -> number .)
    if              reduce using rule 51 (num -> number .)
    let             reduce using rule 51 (num -> number .)
    case            reduce using rule 51 (num -> number .)
    ocurly          reduce using rule 51 (num -> number .)
    not             reduce using rule 51 (num -> number .)
    complement      reduce using rule 51 (num -> number .)
    isvoid          reduce using rule 51 (num -> number .)
    new             reduce using rule 51 (num -> number .)
    number          reduce using rule 51 (num -> number .)
    string          reduce using rule 51 (num -> number .)
    true            reduce using rule 51 (num -> number .)
    false           reduce using rule 51 (num -> number .)
    fi              reduce using rule 51 (num -> number .)


state 77

    (52) str -> string .

    plus            reduce using rule 52 (str -> string .)
    minus           reduce using rule 52 (str -> string .)
    star            reduce using rule 52 (str -> string .)
    div             reduce using rule 52 (str -> string .)
    less            reduce using rule 52 (str -> string .)
    less_equal      reduce using rule 52 (str -> string .)
    equal           reduce using rule 52 (str -> string .)
    semicolon       reduce using rule 52 (str -> string .)
    idx             reduce using rule 52 (str -> string .)
    inx             reduce using rule 52 (str -> string .)
    loop            reduce using rule 52 (str -> string .)
    cbracket        reduce using rule 52 (str -> string .)
    then            reduce using rule 52 (str -> string .)
    of              reduce using rule 52 (str -> string .)
    ccurly          reduce using rule 52 (str -> string .)
    pool            reduce using rule 52 (str -> string .)
    else            reduce using rule 52 (str -> string .)
    obracket        reduce using rule 52 (str -> string .)
    if              reduce using rule 52 (str -> string .)
    let             reduce using rule 52 (str -> string .)
    case            reduce using rule 52 (str -> string .)
    ocurly          reduce using rule 52 (str -> string .)
    not             reduce using rule 52 (str -> string .)
    complement      reduce using rule 52 (str -> string .)
    isvoid          reduce using rule 52 (str -> string .)
    new             reduce using rule 52 (str -> string .)
    number          reduce using rule 52 (str -> string .)
    string          reduce using rule 52 (str -> string .)
    true            reduce using rule 52 (str -> string .)
    false           reduce using rule 52 (str -> string .)
    fi              reduce using rule 52 (str -> string .)


state 78

    (53) bool -> true .

    plus            reduce using rule 53 (bool -> true .)
    minus           reduce using rule 53 (bool -> true .)
    star            reduce using rule 53 (bool -> true .)
    div             reduce using rule 53 (bool -> true .)
    less            reduce using rule 53 (bool -> true .)
    less_equal      reduce using rule 53 (bool -> true .)
    equal           reduce using rule 53 (bool -> true .)
    semicolon       reduce using rule 53 (bool -> true .)
    idx             reduce using rule 53 (bool -> true .)
    inx             reduce using rule 53 (bool -> true .)
    loop            reduce using rule 53 (bool -> true .)
    cbracket        reduce using rule 53 (bool -> true .)
    then            reduce using rule 53 (bool -> true .)
    of              reduce using rule 53 (bool -> true .)
    ccurly          reduce using rule 53 (bool -> true .)
    pool            reduce using rule 53 (bool -> true .)
    else            reduce using rule 53 (bool -> true .)
    obracket        reduce using rule 53 (bool -> true .)
    if              reduce using rule 53 (bool -> true .)
    let             reduce using rule 53 (bool -> true .)
    case            reduce using rule 53 (bool -> true .)
    ocurly          reduce using rule 53 (bool -> true .)
    not             reduce using rule 53 (bool -> true .)
    complement      reduce using rule 53 (bool -> true .)
    isvoid          reduce using rule 53 (bool -> true .)
    new             reduce using rule 53 (bool -> true .)
    number          reduce using rule 53 (bool -> true .)
    string          reduce using rule 53 (bool -> true .)
    true            reduce using rule 53 (bool -> true .)
    false           reduce using rule 53 (bool -> true .)
    fi              reduce using rule 53 (bool -> true .)


state 79

    (54) bool -> false .

    plus            reduce using rule 54 (bool -> false .)
    minus           reduce using rule 54 (bool -> false .)
    star            reduce using rule 54 (bool -> false .)
    div             reduce using rule 54 (bool -> false .)
    less            reduce using rule 54 (bool -> false .)
    less_equal      reduce using rule 54 (bool -> false .)
    equal           reduce using rule 54 (bool -> false .)
    semicolon       reduce using rule 54 (bool -> false .)
    idx             reduce using rule 54 (bool -> false .)
    inx             reduce using rule 54 (bool -> false .)
    loop            reduce using rule 54 (bool -> false .)
    cbracket        reduce using rule 54 (bool -> false .)
    then            reduce using rule 54 (bool -> false .)
    of              reduce using rule 54 (bool -> false .)
    ccurly          reduce using rule 54 (bool -> false .)
    pool            reduce using rule 54 (bool -> false .)
    else            reduce using rule 54 (bool -> false .)
    obracket        reduce using rule 54 (bool -> false .)
    if              reduce using rule 54 (bool -> false .)
    let             reduce using rule 54 (bool -> false .)
    case            reduce using rule 54 (bool -> false .)
    ocurly          reduce using rule 54 (bool -> false .)
    not             reduce using rule 54 (bool -> false .)
    complement      reduce using rule 54 (bool -> false .)
    isvoid          reduce using rule 54 (bool -> false .)
    new             reduce using rule 54 (bool -> false .)
    number          reduce using rule 54 (bool -> false .)
    string          reduce using rule 54 (bool -> false .)
    true            reduce using rule 54 (bool -> false .)
    false           reduce using rule 54 (bool -> false .)
    fi              reduce using rule 54 (bool -> false .)


state 80

    (21) method_decl -> idx obracket formal cbracket doubledot idx . ocurly expr ccurly semicolon feature

    ocurly          shift and go to state 107


state 81

    (24) formal_a -> comma declare_method formal_a .

    cbracket        reduce using rule 24 (formal_a -> comma declare_method formal_a .)


state 82

    (11) assign_expresion -> idx assign . expr
    (26) expr -> . assign_expresion
    (27) expr -> . while_expresion
    (28) expr -> . v_expr
    (11) assign_expresion -> . idx assign expr
    (62) while_expresion -> . while v_expr loop expr pool
    (32) v_expr -> . conditional_expresion
    (33) v_expr -> . let_expresion
    (34) v_expr -> . case_expresion
    (35) v_expr -> . dispatch_expresion
    (36) v_expr -> . dispatch_instance
    (37) v_expr -> . block_expresion
    (38) v_expr -> . binary_operator
    (39) v_expr -> . neg
    (40) v_expr -> . compl
    (41) v_expr -> . is_void
    (42) v_expr -> . new_expresion
    (43) v_expr -> . obracket v_expr cbracket
    (44) v_expr -> . term
    (45) v_expr -> . comparison_expresion
    (60) conditional_expresion -> . if v_expr then expr else expr fi
    (67) let_expresion -> . let let_declr_list inx expr
    (63) case_expresion -> . case expr of case_list esac
    (71) dispatch_expresion -> . idx obracket dispatch_p_list cbracket
    (72) dispatch_instance -> . idx dot idx obracket dispatch_p_list cbracket
    (73) dispatch_instance -> . idx arrobe idx dot idx obracket dispatch_p_list cbracket
    (55) block_expresion -> . ocurly block_expr ccurly
    (2) binary_operator -> . v_expr plus v_expr
    (3) binary_operator -> . v_expr minus v_expr
    (4) binary_operator -> . v_expr star v_expr
    (5) binary_operator -> . v_expr div v_expr
    (9) neg -> . not idx
    (10) compl -> . complement idx
    (61) is_void -> . isvoid expr
    (15) new_expresion -> . new idx
    (46) term -> . var
    (47) term -> . num
    (48) term -> . str
    (49) term -> . bool
    (29) comparison_expresion -> . v_expr less v_expr
    (30) comparison_expresion -> . v_expr less_equal v_expr
    (31) comparison_expresion -> . v_expr equal v_expr
    (50) var -> . idx
    (51) num -> . number
    (52) str -> . string
    (53) bool -> . true
    (54) bool -> . false

    idx             shift and go to state 44
    while           shift and go to state 49
    obracket        shift and go to state 61
    if              shift and go to state 64
    let             shift and go to state 65
    case            shift and go to state 66
    ocurly          shift and go to state 67
    not             shift and go to state 68
    complement      shift and go to state 69
    isvoid          shift and go to state 70
    new             shift and go to state 71
    number          shift and go to state 76
    string          shift and go to state 77
    true            shift and go to state 78
    false           shift and go to state 79

    expr                           shift and go to state 108
    assign_expresion               shift and go to state 46
    while_expresion                shift and go to state 47
    v_expr                         shift and go to state 48
    conditional_expresion          shift and go to state 50
    let_expresion                  shift and go to state 51
    case_expresion                 shift and go to state 52
    dispatch_expresion             shift and go to state 53
    dispatch_instance              shift and go to state 54
    block_expresion                shift and go to state 55
    binary_operator                shift and go to state 56
    neg                            shift and go to state 57
    compl                          shift and go to state 58
    is_void                        shift and go to state 59
    new_expresion                  shift and go to state 60
    term                           shift and go to state 62
    comparison_expresion           shift and go to state 63
    var                            shift and go to state 72
    num                            shift and go to state 73
    str                            shift and go to state 74
    bool                           shift and go to state 75

state 83

    (71) dispatch_expresion -> idx obracket . dispatch_p_list cbracket
    (74) dispatch_p_list -> . v_expr dispatch_p_list
    (75) dispatch_p_list -> . empty
    (32) v_expr -> . conditional_expresion
    (33) v_expr -> . let_expresion
    (34) v_expr -> . case_expresion
    (35) v_expr -> . dispatch_expresion
    (36) v_expr -> . dispatch_instance
    (37) v_expr -> . block_expresion
    (38) v_expr -> . binary_operator
    (39) v_expr -> . neg
    (40) v_expr -> . compl
    (41) v_expr -> . is_void
    (42) v_expr -> . new_expresion
    (43) v_expr -> . obracket v_expr cbracket
    (44) v_expr -> . term
    (45) v_expr -> . comparison_expresion
    (1) empty -> .
    (60) conditional_expresion -> . if v_expr then expr else expr fi
    (67) let_expresion -> . let let_declr_list inx expr
    (63) case_expresion -> . case expr of case_list esac
    (71) dispatch_expresion -> . idx obracket dispatch_p_list cbracket
    (72) dispatch_instance -> . idx dot idx obracket dispatch_p_list cbracket
    (73) dispatch_instance -> . idx arrobe idx dot idx obracket dispatch_p_list cbracket
    (55) block_expresion -> . ocurly block_expr ccurly
    (2) binary_operator -> . v_expr plus v_expr
    (3) binary_operator -> . v_expr minus v_expr
    (4) binary_operator -> . v_expr star v_expr
    (5) binary_operator -> . v_expr div v_expr
    (9) neg -> . not idx
    (10) compl -> . complement idx
    (61) is_void -> . isvoid expr
    (15) new_expresion -> . new idx
    (46) term -> . var
    (47) term -> . num
    (48) term -> . str
    (49) term -> . bool
    (29) comparison_expresion -> . v_expr less v_expr
    (30) comparison_expresion -> . v_expr less_equal v_expr
    (31) comparison_expresion -> . v_expr equal v_expr
    (50) var -> . idx
    (51) num -> . number
    (52) str -> . string
    (53) bool -> . true
    (54) bool -> . false

    obracket        shift and go to state 61
    cbracket        reduce using rule 1 (empty -> .)
    if              shift and go to state 64
    let             shift and go to state 65
    case            shift and go to state 66
    idx             shift and go to state 94
    ocurly          shift and go to state 67
    not             shift and go to state 68
    complement      shift and go to state 69
    isvoid          shift and go to state 70
    new             shift and go to state 71
    number          shift and go to state 76
    string          shift and go to state 77
    true            shift and go to state 78
    false           shift and go to state 79

    dispatch_p_list                shift and go to state 109
    v_expr                         shift and go to state 110
    empty                          shift and go to state 111
    conditional_expresion          shift and go to state 50
    let_expresion                  shift and go to state 51
    case_expresion                 shift and go to state 52
    dispatch_expresion             shift and go to state 53
    dispatch_instance              shift and go to state 54
    block_expresion                shift and go to state 55
    binary_operator                shift and go to state 56
    neg                            shift and go to state 57
    compl                          shift and go to state 58
    is_void                        shift and go to state 59
    new_expresion                  shift and go to state 60
    term                           shift and go to state 62
    comparison_expresion           shift and go to state 63
    var                            shift and go to state 72
    num                            shift and go to state 73
    str                            shift and go to state 74
    bool                           shift and go to state 75

state 84

    (72) dispatch_instance -> idx dot . idx obracket dispatch_p_list cbracket

    idx             shift and go to state 112


state 85

    (73) dispatch_instance -> idx arrobe . idx dot idx obracket dispatch_p_list cbracket

    idx             shift and go to state 113


state 86

    (2) binary_operator -> v_expr plus . v_expr
    (32) v_expr -> . conditional_expresion
    (33) v_expr -> . let_expresion
    (34) v_expr -> . case_expresion
    (35) v_expr -> . dispatch_expresion
    (36) v_expr -> . dispatch_instance
    (37) v_expr -> . block_expresion
    (38) v_expr -> . binary_operator
    (39) v_expr -> . neg
    (40) v_expr -> . compl
    (41) v_expr -> . is_void
    (42) v_expr -> . new_expresion
    (43) v_expr -> . obracket v_expr cbracket
    (44) v_expr -> . term
    (45) v_expr -> . comparison_expresion
    (60) conditional_expresion -> . if v_expr then expr else expr fi
    (67) let_expresion -> . let let_declr_list inx expr
    (63) case_expresion -> . case expr of case_list esac
    (71) dispatch_expresion -> . idx obracket dispatch_p_list cbracket
    (72) dispatch_instance -> . idx dot idx obracket dispatch_p_list cbracket
    (73) dispatch_instance -> . idx arrobe idx dot idx obracket dispatch_p_list cbracket
    (55) block_expresion -> . ocurly block_expr ccurly
    (2) binary_operator -> . v_expr plus v_expr
    (3) binary_operator -> . v_expr minus v_expr
    (4) binary_operator -> . v_expr star v_expr
    (5) binary_operator -> . v_expr div v_expr
    (9) neg -> . not idx
    (10) compl -> . complement idx
    (61) is_void -> . isvoid expr
    (15) new_expresion -> . new idx
    (46) term -> . var
    (47) term -> . num
    (48) term -> . str
    (49) term -> . bool
    (29) comparison_expresion -> . v_expr less v_expr
    (30) comparison_expresion -> . v_expr less_equal v_expr
    (31) comparison_expresion -> . v_expr equal v_expr
    (50) var -> . idx
    (51) num -> . number
    (52) str -> . string
    (53) bool -> . true
    (54) bool -> . false

    obracket        shift and go to state 61
    if              shift and go to state 64
    let             shift and go to state 65
    case            shift and go to state 66
    idx             shift and go to state 94
    ocurly          shift and go to state 67
    not             shift and go to state 68
    complement      shift and go to state 69
    isvoid          shift and go to state 70
    new             shift and go to state 71
    number          shift and go to state 76
    string          shift and go to state 77
    true            shift and go to state 78
    false           shift and go to state 79

    v_expr                         shift and go to state 114
    conditional_expresion          shift and go to state 50
    let_expresion                  shift and go to state 51
    case_expresion                 shift and go to state 52
    dispatch_expresion             shift and go to state 53
    dispatch_instance              shift and go to state 54
    block_expresion                shift and go to state 55
    binary_operator                shift and go to state 56
    neg                            shift and go to state 57
    compl                          shift and go to state 58
    is_void                        shift and go to state 59
    new_expresion                  shift and go to state 60
    term                           shift and go to state 62
    comparison_expresion           shift and go to state 63
    var                            shift and go to state 72
    num                            shift and go to state 73
    str                            shift and go to state 74
    bool                           shift and go to state 75

state 87

    (3) binary_operator -> v_expr minus . v_expr
    (32) v_expr -> . conditional_expresion
    (33) v_expr -> . let_expresion
    (34) v_expr -> . case_expresion
    (35) v_expr -> . dispatch_expresion
    (36) v_expr -> . dispatch_instance
    (37) v_expr -> . block_expresion
    (38) v_expr -> . binary_operator
    (39) v_expr -> . neg
    (40) v_expr -> . compl
    (41) v_expr -> . is_void
    (42) v_expr -> . new_expresion
    (43) v_expr -> . obracket v_expr cbracket
    (44) v_expr -> . term
    (45) v_expr -> . comparison_expresion
    (60) conditional_expresion -> . if v_expr then expr else expr fi
    (67) let_expresion -> . let let_declr_list inx expr
    (63) case_expresion -> . case expr of case_list esac
    (71) dispatch_expresion -> . idx obracket dispatch_p_list cbracket
    (72) dispatch_instance -> . idx dot idx obracket dispatch_p_list cbracket
    (73) dispatch_instance -> . idx arrobe idx dot idx obracket dispatch_p_list cbracket
    (55) block_expresion -> . ocurly block_expr ccurly
    (2) binary_operator -> . v_expr plus v_expr
    (3) binary_operator -> . v_expr minus v_expr
    (4) binary_operator -> . v_expr star v_expr
    (5) binary_operator -> . v_expr div v_expr
    (9) neg -> . not idx
    (10) compl -> . complement idx
    (61) is_void -> . isvoid expr
    (15) new_expresion -> . new idx
    (46) term -> . var
    (47) term -> . num
    (48) term -> . str
    (49) term -> . bool
    (29) comparison_expresion -> . v_expr less v_expr
    (30) comparison_expresion -> . v_expr less_equal v_expr
    (31) comparison_expresion -> . v_expr equal v_expr
    (50) var -> . idx
    (51) num -> . number
    (52) str -> . string
    (53) bool -> . true
    (54) bool -> . false

    obracket        shift and go to state 61
    if              shift and go to state 64
    let             shift and go to state 65
    case            shift and go to state 66
    idx             shift and go to state 94
    ocurly          shift and go to state 67
    not             shift and go to state 68
    complement      shift and go to state 69
    isvoid          shift and go to state 70
    new             shift and go to state 71
    number          shift and go to state 76
    string          shift and go to state 77
    true            shift and go to state 78
    false           shift and go to state 79

    v_expr                         shift and go to state 115
    conditional_expresion          shift and go to state 50
    let_expresion                  shift and go to state 51
    case_expresion                 shift and go to state 52
    dispatch_expresion             shift and go to state 53
    dispatch_instance              shift and go to state 54
    block_expresion                shift and go to state 55
    binary_operator                shift and go to state 56
    neg                            shift and go to state 57
    compl                          shift and go to state 58
    is_void                        shift and go to state 59
    new_expresion                  shift and go to state 60
    term                           shift and go to state 62
    comparison_expresion           shift and go to state 63
    var                            shift and go to state 72
    num                            shift and go to state 73
    str                            shift and go to state 74
    bool                           shift and go to state 75

state 88

    (4) binary_operator -> v_expr star . v_expr
    (32) v_expr -> . conditional_expresion
    (33) v_expr -> . let_expresion
    (34) v_expr -> . case_expresion
    (35) v_expr -> . dispatch_expresion
    (36) v_expr -> . dispatch_instance
    (37) v_expr -> . block_expresion
    (38) v_expr -> . binary_operator
    (39) v_expr -> . neg
    (40) v_expr -> . compl
    (41) v_expr -> . is_void
    (42) v_expr -> . new_expresion
    (43) v_expr -> . obracket v_expr cbracket
    (44) v_expr -> . term
    (45) v_expr -> . comparison_expresion
    (60) conditional_expresion -> . if v_expr then expr else expr fi
    (67) let_expresion -> . let let_declr_list inx expr
    (63) case_expresion -> . case expr of case_list esac
    (71) dispatch_expresion -> . idx obracket dispatch_p_list cbracket
    (72) dispatch_instance -> . idx dot idx obracket dispatch_p_list cbracket
    (73) dispatch_instance -> . idx arrobe idx dot idx obracket dispatch_p_list cbracket
    (55) block_expresion -> . ocurly block_expr ccurly
    (2) binary_operator -> . v_expr plus v_expr
    (3) binary_operator -> . v_expr minus v_expr
    (4) binary_operator -> . v_expr star v_expr
    (5) binary_operator -> . v_expr div v_expr
    (9) neg -> . not idx
    (10) compl -> . complement idx
    (61) is_void -> . isvoid expr
    (15) new_expresion -> . new idx
    (46) term -> . var
    (47) term -> . num
    (48) term -> . str
    (49) term -> . bool
    (29) comparison_expresion -> . v_expr less v_expr
    (30) comparison_expresion -> . v_expr less_equal v_expr
    (31) comparison_expresion -> . v_expr equal v_expr
    (50) var -> . idx
    (51) num -> . number
    (52) str -> . string
    (53) bool -> . true
    (54) bool -> . false

    obracket        shift and go to state 61
    if              shift and go to state 64
    let             shift and go to state 65
    case            shift and go to state 66
    idx             shift and go to state 94
    ocurly          shift and go to state 67
    not             shift and go to state 68
    complement      shift and go to state 69
    isvoid          shift and go to state 70
    new             shift and go to state 71
    number          shift and go to state 76
    string          shift and go to state 77
    true            shift and go to state 78
    false           shift and go to state 79

    v_expr                         shift and go to state 116
    conditional_expresion          shift and go to state 50
    let_expresion                  shift and go to state 51
    case_expresion                 shift and go to state 52
    dispatch_expresion             shift and go to state 53
    dispatch_instance              shift and go to state 54
    block_expresion                shift and go to state 55
    binary_operator                shift and go to state 56
    neg                            shift and go to state 57
    compl                          shift and go to state 58
    is_void                        shift and go to state 59
    new_expresion                  shift and go to state 60
    term                           shift and go to state 62
    comparison_expresion           shift and go to state 63
    var                            shift and go to state 72
    num                            shift and go to state 73
    str                            shift and go to state 74
    bool                           shift and go to state 75

state 89

    (5) binary_operator -> v_expr div . v_expr
    (32) v_expr -> . conditional_expresion
    (33) v_expr -> . let_expresion
    (34) v_expr -> . case_expresion
    (35) v_expr -> . dispatch_expresion
    (36) v_expr -> . dispatch_instance
    (37) v_expr -> . block_expresion
    (38) v_expr -> . binary_operator
    (39) v_expr -> . neg
    (40) v_expr -> . compl
    (41) v_expr -> . is_void
    (42) v_expr -> . new_expresion
    (43) v_expr -> . obracket v_expr cbracket
    (44) v_expr -> . term
    (45) v_expr -> . comparison_expresion
    (60) conditional_expresion -> . if v_expr then expr else expr fi
    (67) let_expresion -> . let let_declr_list inx expr
    (63) case_expresion -> . case expr of case_list esac
    (71) dispatch_expresion -> . idx obracket dispatch_p_list cbracket
    (72) dispatch_instance -> . idx dot idx obracket dispatch_p_list cbracket
    (73) dispatch_instance -> . idx arrobe idx dot idx obracket dispatch_p_list cbracket
    (55) block_expresion -> . ocurly block_expr ccurly
    (2) binary_operator -> . v_expr plus v_expr
    (3) binary_operator -> . v_expr minus v_expr
    (4) binary_operator -> . v_expr star v_expr
    (5) binary_operator -> . v_expr div v_expr
    (9) neg -> . not idx
    (10) compl -> . complement idx
    (61) is_void -> . isvoid expr
    (15) new_expresion -> . new idx
    (46) term -> . var
    (47) term -> . num
    (48) term -> . str
    (49) term -> . bool
    (29) comparison_expresion -> . v_expr less v_expr
    (30) comparison_expresion -> . v_expr less_equal v_expr
    (31) comparison_expresion -> . v_expr equal v_expr
    (50) var -> . idx
    (51) num -> . number
    (52) str -> . string
    (53) bool -> . true
    (54) bool -> . false

    obracket        shift and go to state 61
    if              shift and go to state 64
    let             shift and go to state 65
    case            shift and go to state 66
    idx             shift and go to state 94
    ocurly          shift and go to state 67
    not             shift and go to state 68
    complement      shift and go to state 69
    isvoid          shift and go to state 70
    new             shift and go to state 71
    number          shift and go to state 76
    string          shift and go to state 77
    true            shift and go to state 78
    false           shift and go to state 79

    v_expr                         shift and go to state 117
    conditional_expresion          shift and go to state 50
    let_expresion                  shift and go to state 51
    case_expresion                 shift and go to state 52
    dispatch_expresion             shift and go to state 53
    dispatch_instance              shift and go to state 54
    block_expresion                shift and go to state 55
    binary_operator                shift and go to state 56
    neg                            shift and go to state 57
    compl                          shift and go to state 58
    is_void                        shift and go to state 59
    new_expresion                  shift and go to state 60
    term                           shift and go to state 62
    comparison_expresion           shift and go to state 63
    var                            shift and go to state 72
    num                            shift and go to state 73
    str                            shift and go to state 74
    bool                           shift and go to state 75

state 90

    (29) comparison_expresion -> v_expr less . v_expr
    (32) v_expr -> . conditional_expresion
    (33) v_expr -> . let_expresion
    (34) v_expr -> . case_expresion
    (35) v_expr -> . dispatch_expresion
    (36) v_expr -> . dispatch_instance
    (37) v_expr -> . block_expresion
    (38) v_expr -> . binary_operator
    (39) v_expr -> . neg
    (40) v_expr -> . compl
    (41) v_expr -> . is_void
    (42) v_expr -> . new_expresion
    (43) v_expr -> . obracket v_expr cbracket
    (44) v_expr -> . term
    (45) v_expr -> . comparison_expresion
    (60) conditional_expresion -> . if v_expr then expr else expr fi
    (67) let_expresion -> . let let_declr_list inx expr
    (63) case_expresion -> . case expr of case_list esac
    (71) dispatch_expresion -> . idx obracket dispatch_p_list cbracket
    (72) dispatch_instance -> . idx dot idx obracket dispatch_p_list cbracket
    (73) dispatch_instance -> . idx arrobe idx dot idx obracket dispatch_p_list cbracket
    (55) block_expresion -> . ocurly block_expr ccurly
    (2) binary_operator -> . v_expr plus v_expr
    (3) binary_operator -> . v_expr minus v_expr
    (4) binary_operator -> . v_expr star v_expr
    (5) binary_operator -> . v_expr div v_expr
    (9) neg -> . not idx
    (10) compl -> . complement idx
    (61) is_void -> . isvoid expr
    (15) new_expresion -> . new idx
    (46) term -> . var
    (47) term -> . num
    (48) term -> . str
    (49) term -> . bool
    (29) comparison_expresion -> . v_expr less v_expr
    (30) comparison_expresion -> . v_expr less_equal v_expr
    (31) comparison_expresion -> . v_expr equal v_expr
    (50) var -> . idx
    (51) num -> . number
    (52) str -> . string
    (53) bool -> . true
    (54) bool -> . false

    obracket        shift and go to state 61
    if              shift and go to state 64
    let             shift and go to state 65
    case            shift and go to state 66
    idx             shift and go to state 94
    ocurly          shift and go to state 67
    not             shift and go to state 68
    complement      shift and go to state 69
    isvoid          shift and go to state 70
    new             shift and go to state 71
    number          shift and go to state 76
    string          shift and go to state 77
    true            shift and go to state 78
    false           shift and go to state 79

    v_expr                         shift and go to state 118
    conditional_expresion          shift and go to state 50
    let_expresion                  shift and go to state 51
    case_expresion                 shift and go to state 52
    dispatch_expresion             shift and go to state 53
    dispatch_instance              shift and go to state 54
    block_expresion                shift and go to state 55
    binary_operator                shift and go to state 56
    neg                            shift and go to state 57
    compl                          shift and go to state 58
    is_void                        shift and go to state 59
    new_expresion                  shift and go to state 60
    term                           shift and go to state 62
    comparison_expresion           shift and go to state 63
    var                            shift and go to state 72
    num                            shift and go to state 73
    str                            shift and go to state 74
    bool                           shift and go to state 75

state 91

    (30) comparison_expresion -> v_expr less_equal . v_expr
    (32) v_expr -> . conditional_expresion
    (33) v_expr -> . let_expresion
    (34) v_expr -> . case_expresion
    (35) v_expr -> . dispatch_expresion
    (36) v_expr -> . dispatch_instance
    (37) v_expr -> . block_expresion
    (38) v_expr -> . binary_operator
    (39) v_expr -> . neg
    (40) v_expr -> . compl
    (41) v_expr -> . is_void
    (42) v_expr -> . new_expresion
    (43) v_expr -> . obracket v_expr cbracket
    (44) v_expr -> . term
    (45) v_expr -> . comparison_expresion
    (60) conditional_expresion -> . if v_expr then expr else expr fi
    (67) let_expresion -> . let let_declr_list inx expr
    (63) case_expresion -> . case expr of case_list esac
    (71) dispatch_expresion -> . idx obracket dispatch_p_list cbracket
    (72) dispatch_instance -> . idx dot idx obracket dispatch_p_list cbracket
    (73) dispatch_instance -> . idx arrobe idx dot idx obracket dispatch_p_list cbracket
    (55) block_expresion -> . ocurly block_expr ccurly
    (2) binary_operator -> . v_expr plus v_expr
    (3) binary_operator -> . v_expr minus v_expr
    (4) binary_operator -> . v_expr star v_expr
    (5) binary_operator -> . v_expr div v_expr
    (9) neg -> . not idx
    (10) compl -> . complement idx
    (61) is_void -> . isvoid expr
    (15) new_expresion -> . new idx
    (46) term -> . var
    (47) term -> . num
    (48) term -> . str
    (49) term -> . bool
    (29) comparison_expresion -> . v_expr less v_expr
    (30) comparison_expresion -> . v_expr less_equal v_expr
    (31) comparison_expresion -> . v_expr equal v_expr
    (50) var -> . idx
    (51) num -> . number
    (52) str -> . string
    (53) bool -> . true
    (54) bool -> . false

    obracket        shift and go to state 61
    if              shift and go to state 64
    let             shift and go to state 65
    case            shift and go to state 66
    idx             shift and go to state 94
    ocurly          shift and go to state 67
    not             shift and go to state 68
    complement      shift and go to state 69
    isvoid          shift and go to state 70
    new             shift and go to state 71
    number          shift and go to state 76
    string          shift and go to state 77
    true            shift and go to state 78
    false           shift and go to state 79

    v_expr                         shift and go to state 119
    conditional_expresion          shift and go to state 50
    let_expresion                  shift and go to state 51
    case_expresion                 shift and go to state 52
    dispatch_expresion             shift and go to state 53
    dispatch_instance              shift and go to state 54
    block_expresion                shift and go to state 55
    binary_operator                shift and go to state 56
    neg                            shift and go to state 57
    compl                          shift and go to state 58
    is_void                        shift and go to state 59
    new_expresion                  shift and go to state 60
    term                           shift and go to state 62
    comparison_expresion           shift and go to state 63
    var                            shift and go to state 72
    num                            shift and go to state 73
    str                            shift and go to state 74
    bool                           shift and go to state 75

state 92

    (31) comparison_expresion -> v_expr equal . v_expr
    (32) v_expr -> . conditional_expresion
    (33) v_expr -> . let_expresion
    (34) v_expr -> . case_expresion
    (35) v_expr -> . dispatch_expresion
    (36) v_expr -> . dispatch_instance
    (37) v_expr -> . block_expresion
    (38) v_expr -> . binary_operator
    (39) v_expr -> . neg
    (40) v_expr -> . compl
    (41) v_expr -> . is_void
    (42) v_expr -> . new_expresion
    (43) v_expr -> . obracket v_expr cbracket
    (44) v_expr -> . term
    (45) v_expr -> . comparison_expresion
    (60) conditional_expresion -> . if v_expr then expr else expr fi
    (67) let_expresion -> . let let_declr_list inx expr
    (63) case_expresion -> . case expr of case_list esac
    (71) dispatch_expresion -> . idx obracket dispatch_p_list cbracket
    (72) dispatch_instance -> . idx dot idx obracket dispatch_p_list cbracket
    (73) dispatch_instance -> . idx arrobe idx dot idx obracket dispatch_p_list cbracket
    (55) block_expresion -> . ocurly block_expr ccurly
    (2) binary_operator -> . v_expr plus v_expr
    (3) binary_operator -> . v_expr minus v_expr
    (4) binary_operator -> . v_expr star v_expr
    (5) binary_operator -> . v_expr div v_expr
    (9) neg -> . not idx
    (10) compl -> . complement idx
    (61) is_void -> . isvoid expr
    (15) new_expresion -> . new idx
    (46) term -> . var
    (47) term -> . num
    (48) term -> . str
    (49) term -> . bool
    (29) comparison_expresion -> . v_expr less v_expr
    (30) comparison_expresion -> . v_expr less_equal v_expr
    (31) comparison_expresion -> . v_expr equal v_expr
    (50) var -> . idx
    (51) num -> . number
    (52) str -> . string
    (53) bool -> . true
    (54) bool -> . false

    obracket        shift and go to state 61
    if              shift and go to state 64
    let             shift and go to state 65
    case            shift and go to state 66
    idx             shift and go to state 94
    ocurly          shift and go to state 67
    not             shift and go to state 68
    complement      shift and go to state 69
    isvoid          shift and go to state 70
    new             shift and go to state 71
    number          shift and go to state 76
    string          shift and go to state 77
    true            shift and go to state 78
    false           shift and go to state 79

    v_expr                         shift and go to state 120
    conditional_expresion          shift and go to state 50
    let_expresion                  shift and go to state 51
    case_expresion                 shift and go to state 52
    dispatch_expresion             shift and go to state 53
    dispatch_instance              shift and go to state 54
    block_expresion                shift and go to state 55
    binary_operator                shift and go to state 56
    neg                            shift and go to state 57
    compl                          shift and go to state 58
    is_void                        shift and go to state 59
    new_expresion                  shift and go to state 60
    term                           shift and go to state 62
    comparison_expresion           shift and go to state 63
    var                            shift and go to state 72
    num                            shift and go to state 73
    str                            shift and go to state 74
    bool                           shift and go to state 75

state 93

    (62) while_expresion -> while v_expr . loop expr pool
    (2) binary_operator -> v_expr . plus v_expr
    (3) binary_operator -> v_expr . minus v_expr
    (4) binary_operator -> v_expr . star v_expr
    (5) binary_operator -> v_expr . div v_expr
    (29) comparison_expresion -> v_expr . less v_expr
    (30) comparison_expresion -> v_expr . less_equal v_expr
    (31) comparison_expresion -> v_expr . equal v_expr

    loop            shift and go to state 121
    plus            shift and go to state 86
    minus           shift and go to state 87
    star            shift and go to state 88
    div             shift and go to state 89
    less            shift and go to state 90
    less_equal      shift and go to state 91
    equal           shift and go to state 92


state 94

    (71) dispatch_expresion -> idx . obracket dispatch_p_list cbracket
    (72) dispatch_instance -> idx . dot idx obracket dispatch_p_list cbracket
    (73) dispatch_instance -> idx . arrobe idx dot idx obracket dispatch_p_list cbracket
    (50) var -> idx .

  ! shift/reduce conflict for obracket resolved as shift
    obracket        shift and go to state 83
    dot             shift and go to state 84
    arrobe          shift and go to state 85
    loop            reduce using rule 50 (var -> idx .)
    plus            reduce using rule 50 (var -> idx .)
    minus           reduce using rule 50 (var -> idx .)
    star            reduce using rule 50 (var -> idx .)
    div             reduce using rule 50 (var -> idx .)
    less            reduce using rule 50 (var -> idx .)
    less_equal      reduce using rule 50 (var -> idx .)
    equal           reduce using rule 50 (var -> idx .)
    cbracket        reduce using rule 50 (var -> idx .)
    then            reduce using rule 50 (var -> idx .)
    if              reduce using rule 50 (var -> idx .)
    let             reduce using rule 50 (var -> idx .)
    case            reduce using rule 50 (var -> idx .)
    idx             reduce using rule 50 (var -> idx .)
    ocurly          reduce using rule 50 (var -> idx .)
    not             reduce using rule 50 (var -> idx .)
    complement      reduce using rule 50 (var -> idx .)
    isvoid          reduce using rule 50 (var -> idx .)
    new             reduce using rule 50 (var -> idx .)
    number          reduce using rule 50 (var -> idx .)
    string          reduce using rule 50 (var -> idx .)
    true            reduce using rule 50 (var -> idx .)
    false           reduce using rule 50 (var -> idx .)
    semicolon       reduce using rule 50 (var -> idx .)
    inx             reduce using rule 50 (var -> idx .)
    of              reduce using rule 50 (var -> idx .)
    ccurly          reduce using rule 50 (var -> idx .)
    pool            reduce using rule 50 (var -> idx .)
    else            reduce using rule 50 (var -> idx .)
    fi              reduce using rule 50 (var -> idx .)

  ! obracket        [ reduce using rule 50 (var -> idx .) ]


state 95

    (43) v_expr -> obracket v_expr . cbracket
    (2) binary_operator -> v_expr . plus v_expr
    (3) binary_operator -> v_expr . minus v_expr
    (4) binary_operator -> v_expr . star v_expr
    (5) binary_operator -> v_expr . div v_expr
    (29) comparison_expresion -> v_expr . less v_expr
    (30) comparison_expresion -> v_expr . less_equal v_expr
    (31) comparison_expresion -> v_expr . equal v_expr

    cbracket        shift and go to state 122
    plus            shift and go to state 86
    minus           shift and go to state 87
    star            shift and go to state 88
    div             shift and go to state 89
    less            shift and go to state 90
    less_equal      shift and go to state 91
    equal           shift and go to state 92


state 96

    (60) conditional_expresion -> if v_expr . then expr else expr fi
    (2) binary_operator -> v_expr . plus v_expr
    (3) binary_operator -> v_expr . minus v_expr
    (4) binary_operator -> v_expr . star v_expr
    (5) binary_operator -> v_expr . div v_expr
    (29) comparison_expresion -> v_expr . less v_expr
    (30) comparison_expresion -> v_expr . less_equal v_expr
    (31) comparison_expresion -> v_expr . equal v_expr

    then            shift and go to state 123
    plus            shift and go to state 86
    minus           shift and go to state 87
    star            shift and go to state 88
    div             shift and go to state 89
    less            shift and go to state 90
    less_equal      shift and go to state 91
    equal           shift and go to state 92


state 97

    (67) let_expresion -> let let_declr_list . inx expr

    inx             shift and go to state 124


state 98

    (68) let_declr_list -> declare_expresion . let_declr_list_a
    (69) let_declr_list_a -> . declare_expresion let_declr_list_a
    (70) let_declr_list_a -> . empty
    (12) declare_expresion -> . idx doubledot idx assign expr
    (13) declare_expresion -> . idx doubledot idx
    (1) empty -> .

    idx             shift and go to state 99
    inx             reduce using rule 1 (empty -> .)

    declare_expresion              shift and go to state 125
    let_declr_list_a               shift and go to state 126
    empty                          shift and go to state 127

state 99

    (12) declare_expresion -> idx . doubledot idx assign expr
    (13) declare_expresion -> idx . doubledot idx

    doubledot       shift and go to state 24


state 100

    (63) case_expresion -> case expr . of case_list esac

    of              shift and go to state 128


state 101

    (55) block_expresion -> ocurly block_expr . ccurly

    ccurly          shift and go to state 129


state 102

    (56) block_expr -> expr . semicolon block_expr_a

    semicolon       shift and go to state 130


state 103

    (9) neg -> not idx .

    plus            reduce using rule 9 (neg -> not idx .)
    minus           reduce using rule 9 (neg -> not idx .)
    star            reduce using rule 9 (neg -> not idx .)
    div             reduce using rule 9 (neg -> not idx .)
    less            reduce using rule 9 (neg -> not idx .)
    less_equal      reduce using rule 9 (neg -> not idx .)
    equal           reduce using rule 9 (neg -> not idx .)
    semicolon       reduce using rule 9 (neg -> not idx .)
    idx             reduce using rule 9 (neg -> not idx .)
    inx             reduce using rule 9 (neg -> not idx .)
    loop            reduce using rule 9 (neg -> not idx .)
    cbracket        reduce using rule 9 (neg -> not idx .)
    then            reduce using rule 9 (neg -> not idx .)
    of              reduce using rule 9 (neg -> not idx .)
    ccurly          reduce using rule 9 (neg -> not idx .)
    pool            reduce using rule 9 (neg -> not idx .)
    else            reduce using rule 9 (neg -> not idx .)
    obracket        reduce using rule 9 (neg -> not idx .)
    if              reduce using rule 9 (neg -> not idx .)
    let             reduce using rule 9 (neg -> not idx .)
    case            reduce using rule 9 (neg -> not idx .)
    ocurly          reduce using rule 9 (neg -> not idx .)
    not             reduce using rule 9 (neg -> not idx .)
    complement      reduce using rule 9 (neg -> not idx .)
    isvoid          reduce using rule 9 (neg -> not idx .)
    new             reduce using rule 9 (neg -> not idx .)
    number          reduce using rule 9 (neg -> not idx .)
    string          reduce using rule 9 (neg -> not idx .)
    true            reduce using rule 9 (neg -> not idx .)
    false           reduce using rule 9 (neg -> not idx .)
    fi              reduce using rule 9 (neg -> not idx .)


state 104

    (10) compl -> complement idx .

    plus            reduce using rule 10 (compl -> complement idx .)
    minus           reduce using rule 10 (compl -> complement idx .)
    star            reduce using rule 10 (compl -> complement idx .)
    div             reduce using rule 10 (compl -> complement idx .)
    less            reduce using rule 10 (compl -> complement idx .)
    less_equal      reduce using rule 10 (compl -> complement idx .)
    equal           reduce using rule 10 (compl -> complement idx .)
    semicolon       reduce using rule 10 (compl -> complement idx .)
    idx             reduce using rule 10 (compl -> complement idx .)
    inx             reduce using rule 10 (compl -> complement idx .)
    loop            reduce using rule 10 (compl -> complement idx .)
    cbracket        reduce using rule 10 (compl -> complement idx .)
    then            reduce using rule 10 (compl -> complement idx .)
    of              reduce using rule 10 (compl -> complement idx .)
    ccurly          reduce using rule 10 (compl -> complement idx .)
    pool            reduce using rule 10 (compl -> complement idx .)
    else            reduce using rule 10 (compl -> complement idx .)
    obracket        reduce using rule 10 (compl -> complement idx .)
    if              reduce using rule 10 (compl -> complement idx .)
    let             reduce using rule 10 (compl -> complement idx .)
    case            reduce using rule 10 (compl -> complement idx .)
    ocurly          reduce using rule 10 (compl -> complement idx .)
    not             reduce using rule 10 (compl -> complement idx .)
    complement      reduce using rule 10 (compl -> complement idx .)
    isvoid          reduce using rule 10 (compl -> complement idx .)
    new             reduce using rule 10 (compl -> complement idx .)
    number          reduce using rule 10 (compl -> complement idx .)
    string          reduce using rule 10 (compl -> complement idx .)
    true            reduce using rule 10 (compl -> complement idx .)
    false           reduce using rule 10 (compl -> complement idx .)
    fi              reduce using rule 10 (compl -> complement idx .)


state 105

    (61) is_void -> isvoid expr .

    plus            reduce using rule 61 (is_void -> isvoid expr .)
    minus           reduce using rule 61 (is_void -> isvoid expr .)
    star            reduce using rule 61 (is_void -> isvoid expr .)
    div             reduce using rule 61 (is_void -> isvoid expr .)
    less            reduce using rule 61 (is_void -> isvoid expr .)
    less_equal      reduce using rule 61 (is_void -> isvoid expr .)
    equal           reduce using rule 61 (is_void -> isvoid expr .)
    semicolon       reduce using rule 61 (is_void -> isvoid expr .)
    idx             reduce using rule 61 (is_void -> isvoid expr .)
    inx             reduce using rule 61 (is_void -> isvoid expr .)
    loop            reduce using rule 61 (is_void -> isvoid expr .)
    cbracket        reduce using rule 61 (is_void -> isvoid expr .)
    then            reduce using rule 61 (is_void -> isvoid expr .)
    of              reduce using rule 61 (is_void -> isvoid expr .)
    ccurly          reduce using rule 61 (is_void -> isvoid expr .)
    pool            reduce using rule 61 (is_void -> isvoid expr .)
    else            reduce using rule 61 (is_void -> isvoid expr .)
    obracket        reduce using rule 61 (is_void -> isvoid expr .)
    if              reduce using rule 61 (is_void -> isvoid expr .)
    let             reduce using rule 61 (is_void -> isvoid expr .)
    case            reduce using rule 61 (is_void -> isvoid expr .)
    ocurly          reduce using rule 61 (is_void -> isvoid expr .)
    not             reduce using rule 61 (is_void -> isvoid expr .)
    complement      reduce using rule 61 (is_void -> isvoid expr .)
    isvoid          reduce using rule 61 (is_void -> isvoid expr .)
    new             reduce using rule 61 (is_void -> isvoid expr .)
    number          reduce using rule 61 (is_void -> isvoid expr .)
    string          reduce using rule 61 (is_void -> isvoid expr .)
    true            reduce using rule 61 (is_void -> isvoid expr .)
    false           reduce using rule 61 (is_void -> isvoid expr .)
    fi              reduce using rule 61 (is_void -> isvoid expr .)


state 106

    (15) new_expresion -> new idx .

    plus            reduce using rule 15 (new_expresion -> new idx .)
    minus           reduce using rule 15 (new_expresion -> new idx .)
    star            reduce using rule 15 (new_expresion -> new idx .)
    div             reduce using rule 15 (new_expresion -> new idx .)
    less            reduce using rule 15 (new_expresion -> new idx .)
    less_equal      reduce using rule 15 (new_expresion -> new idx .)
    equal           reduce using rule 15 (new_expresion -> new idx .)
    semicolon       reduce using rule 15 (new_expresion -> new idx .)
    idx             reduce using rule 15 (new_expresion -> new idx .)
    inx             reduce using rule 15 (new_expresion -> new idx .)
    loop            reduce using rule 15 (new_expresion -> new idx .)
    cbracket        reduce using rule 15 (new_expresion -> new idx .)
    then            reduce using rule 15 (new_expresion -> new idx .)
    of              reduce using rule 15 (new_expresion -> new idx .)
    ccurly          reduce using rule 15 (new_expresion -> new idx .)
    pool            reduce using rule 15 (new_expresion -> new idx .)
    else            reduce using rule 15 (new_expresion -> new idx .)
    obracket        reduce using rule 15 (new_expresion -> new idx .)
    if              reduce using rule 15 (new_expresion -> new idx .)
    let             reduce using rule 15 (new_expresion -> new idx .)
    case            reduce using rule 15 (new_expresion -> new idx .)
    ocurly          reduce using rule 15 (new_expresion -> new idx .)
    not             reduce using rule 15 (new_expresion -> new idx .)
    complement      reduce using rule 15 (new_expresion -> new idx .)
    isvoid          reduce using rule 15 (new_expresion -> new idx .)
    new             reduce using rule 15 (new_expresion -> new idx .)
    number          reduce using rule 15 (new_expresion -> new idx .)
    string          reduce using rule 15 (new_expresion -> new idx .)
    true            reduce using rule 15 (new_expresion -> new idx .)
    false           reduce using rule 15 (new_expresion -> new idx .)
    fi              reduce using rule 15 (new_expresion -> new idx .)


state 107

    (21) method_decl -> idx obracket formal cbracket doubledot idx ocurly . expr ccurly semicolon feature
    (26) expr -> . assign_expresion
    (27) expr -> . while_expresion
    (28) expr -> . v_expr
    (11) assign_expresion -> . idx assign expr
    (62) while_expresion -> . while v_expr loop expr pool
    (32) v_expr -> . conditional_expresion
    (33) v_expr -> . let_expresion
    (34) v_expr -> . case_expresion
    (35) v_expr -> . dispatch_expresion
    (36) v_expr -> . dispatch_instance
    (37) v_expr -> . block_expresion
    (38) v_expr -> . binary_operator
    (39) v_expr -> . neg
    (40) v_expr -> . compl
    (41) v_expr -> . is_void
    (42) v_expr -> . new_expresion
    (43) v_expr -> . obracket v_expr cbracket
    (44) v_expr -> . term
    (45) v_expr -> . comparison_expresion
    (60) conditional_expresion -> . if v_expr then expr else expr fi
    (67) let_expresion -> . let let_declr_list inx expr
    (63) case_expresion -> . case expr of case_list esac
    (71) dispatch_expresion -> . idx obracket dispatch_p_list cbracket
    (72) dispatch_instance -> . idx dot idx obracket dispatch_p_list cbracket
    (73) dispatch_instance -> . idx arrobe idx dot idx obracket dispatch_p_list cbracket
    (55) block_expresion -> . ocurly block_expr ccurly
    (2) binary_operator -> . v_expr plus v_expr
    (3) binary_operator -> . v_expr minus v_expr
    (4) binary_operator -> . v_expr star v_expr
    (5) binary_operator -> . v_expr div v_expr
    (9) neg -> . not idx
    (10) compl -> . complement idx
    (61) is_void -> . isvoid expr
    (15) new_expresion -> . new idx
    (46) term -> . var
    (47) term -> . num
    (48) term -> . str
    (49) term -> . bool
    (29) comparison_expresion -> . v_expr less v_expr
    (30) comparison_expresion -> . v_expr less_equal v_expr
    (31) comparison_expresion -> . v_expr equal v_expr
    (50) var -> . idx
    (51) num -> . number
    (52) str -> . string
    (53) bool -> . true
    (54) bool -> . false

    idx             shift and go to state 44
    while           shift and go to state 49
    obracket        shift and go to state 61
    if              shift and go to state 64
    let             shift and go to state 65
    case            shift and go to state 66
    ocurly          shift and go to state 67
    not             shift and go to state 68
    complement      shift and go to state 69
    isvoid          shift and go to state 70
    new             shift and go to state 71
    number          shift and go to state 76
    string          shift and go to state 77
    true            shift and go to state 78
    false           shift and go to state 79

    expr                           shift and go to state 131
    assign_expresion               shift and go to state 46
    while_expresion                shift and go to state 47
    v_expr                         shift and go to state 48
    conditional_expresion          shift and go to state 50
    let_expresion                  shift and go to state 51
    case_expresion                 shift and go to state 52
    dispatch_expresion             shift and go to state 53
    dispatch_instance              shift and go to state 54
    block_expresion                shift and go to state 55
    binary_operator                shift and go to state 56
    neg                            shift and go to state 57
    compl                          shift and go to state 58
    is_void                        shift and go to state 59
    new_expresion                  shift and go to state 60
    term                           shift and go to state 62
    comparison_expresion           shift and go to state 63
    var                            shift and go to state 72
    num                            shift and go to state 73
    str                            shift and go to state 74
    bool                           shift and go to state 75

state 108

    (11) assign_expresion -> idx assign expr .

    semicolon       reduce using rule 11 (assign_expresion -> idx assign expr .)
    idx             reduce using rule 11 (assign_expresion -> idx assign expr .)
    inx             reduce using rule 11 (assign_expresion -> idx assign expr .)
    of              reduce using rule 11 (assign_expresion -> idx assign expr .)
    plus            reduce using rule 11 (assign_expresion -> idx assign expr .)
    minus           reduce using rule 11 (assign_expresion -> idx assign expr .)
    star            reduce using rule 11 (assign_expresion -> idx assign expr .)
    div             reduce using rule 11 (assign_expresion -> idx assign expr .)
    less            reduce using rule 11 (assign_expresion -> idx assign expr .)
    less_equal      reduce using rule 11 (assign_expresion -> idx assign expr .)
    equal           reduce using rule 11 (assign_expresion -> idx assign expr .)
    loop            reduce using rule 11 (assign_expresion -> idx assign expr .)
    cbracket        reduce using rule 11 (assign_expresion -> idx assign expr .)
    then            reduce using rule 11 (assign_expresion -> idx assign expr .)
    ccurly          reduce using rule 11 (assign_expresion -> idx assign expr .)
    pool            reduce using rule 11 (assign_expresion -> idx assign expr .)
    else            reduce using rule 11 (assign_expresion -> idx assign expr .)
    obracket        reduce using rule 11 (assign_expresion -> idx assign expr .)
    if              reduce using rule 11 (assign_expresion -> idx assign expr .)
    let             reduce using rule 11 (assign_expresion -> idx assign expr .)
    case            reduce using rule 11 (assign_expresion -> idx assign expr .)
    ocurly          reduce using rule 11 (assign_expresion -> idx assign expr .)
    not             reduce using rule 11 (assign_expresion -> idx assign expr .)
    complement      reduce using rule 11 (assign_expresion -> idx assign expr .)
    isvoid          reduce using rule 11 (assign_expresion -> idx assign expr .)
    new             reduce using rule 11 (assign_expresion -> idx assign expr .)
    number          reduce using rule 11 (assign_expresion -> idx assign expr .)
    string          reduce using rule 11 (assign_expresion -> idx assign expr .)
    true            reduce using rule 11 (assign_expresion -> idx assign expr .)
    false           reduce using rule 11 (assign_expresion -> idx assign expr .)
    fi              reduce using rule 11 (assign_expresion -> idx assign expr .)


state 109

    (71) dispatch_expresion -> idx obracket dispatch_p_list . cbracket

    cbracket        shift and go to state 132


state 110

    (74) dispatch_p_list -> v_expr . dispatch_p_list
    (2) binary_operator -> v_expr . plus v_expr
    (3) binary_operator -> v_expr . minus v_expr
    (4) binary_operator -> v_expr . star v_expr
    (5) binary_operator -> v_expr . div v_expr
    (29) comparison_expresion -> v_expr . less v_expr
    (30) comparison_expresion -> v_expr . less_equal v_expr
    (31) comparison_expresion -> v_expr . equal v_expr
    (74) dispatch_p_list -> . v_expr dispatch_p_list
    (75) dispatch_p_list -> . empty
    (32) v_expr -> . conditional_expresion
    (33) v_expr -> . let_expresion
    (34) v_expr -> . case_expresion
    (35) v_expr -> . dispatch_expresion
    (36) v_expr -> . dispatch_instance
    (37) v_expr -> . block_expresion
    (38) v_expr -> . binary_operator
    (39) v_expr -> . neg
    (40) v_expr -> . compl
    (41) v_expr -> . is_void
    (42) v_expr -> . new_expresion
    (43) v_expr -> . obracket v_expr cbracket
    (44) v_expr -> . term
    (45) v_expr -> . comparison_expresion
    (1) empty -> .
    (60) conditional_expresion -> . if v_expr then expr else expr fi
    (67) let_expresion -> . let let_declr_list inx expr
    (63) case_expresion -> . case expr of case_list esac
    (71) dispatch_expresion -> . idx obracket dispatch_p_list cbracket
    (72) dispatch_instance -> . idx dot idx obracket dispatch_p_list cbracket
    (73) dispatch_instance -> . idx arrobe idx dot idx obracket dispatch_p_list cbracket
    (55) block_expresion -> . ocurly block_expr ccurly
    (2) binary_operator -> . v_expr plus v_expr
    (3) binary_operator -> . v_expr minus v_expr
    (4) binary_operator -> . v_expr star v_expr
    (5) binary_operator -> . v_expr div v_expr
    (9) neg -> . not idx
    (10) compl -> . complement idx
    (61) is_void -> . isvoid expr
    (15) new_expresion -> . new idx
    (46) term -> . var
    (47) term -> . num
    (48) term -> . str
    (49) term -> . bool
    (29) comparison_expresion -> . v_expr less v_expr
    (30) comparison_expresion -> . v_expr less_equal v_expr
    (31) comparison_expresion -> . v_expr equal v_expr
    (50) var -> . idx
    (51) num -> . number
    (52) str -> . string
    (53) bool -> . true
    (54) bool -> . false

    plus            shift and go to state 86
    minus           shift and go to state 87
    star            shift and go to state 88
    div             shift and go to state 89
    less            shift and go to state 90
    less_equal      shift and go to state 91
    equal           shift and go to state 92
    obracket        shift and go to state 61
    cbracket        reduce using rule 1 (empty -> .)
    if              shift and go to state 64
    let             shift and go to state 65
    case            shift and go to state 66
    idx             shift and go to state 94
    ocurly          shift and go to state 67
    not             shift and go to state 68
    complement      shift and go to state 69
    isvoid          shift and go to state 70
    new             shift and go to state 71
    number          shift and go to state 76
    string          shift and go to state 77
    true            shift and go to state 78
    false           shift and go to state 79

    v_expr                         shift and go to state 110
    dispatch_p_list                shift and go to state 133
    empty                          shift and go to state 111
    conditional_expresion          shift and go to state 50
    let_expresion                  shift and go to state 51
    case_expresion                 shift and go to state 52
    dispatch_expresion             shift and go to state 53
    dispatch_instance              shift and go to state 54
    block_expresion                shift and go to state 55
    binary_operator                shift and go to state 56
    neg                            shift and go to state 57
    compl                          shift and go to state 58
    is_void                        shift and go to state 59
    new_expresion                  shift and go to state 60
    term                           shift and go to state 62
    comparison_expresion           shift and go to state 63
    var                            shift and go to state 72
    num                            shift and go to state 73
    str                            shift and go to state 74
    bool                           shift and go to state 75

state 111

    (75) dispatch_p_list -> empty .

    cbracket        reduce using rule 75 (dispatch_p_list -> empty .)


state 112

    (72) dispatch_instance -> idx dot idx . obracket dispatch_p_list cbracket

    obracket        shift and go to state 134


state 113

    (73) dispatch_instance -> idx arrobe idx . dot idx obracket dispatch_p_list cbracket

    dot             shift and go to state 135


state 114

    (2) binary_operator -> v_expr plus v_expr .
    (2) binary_operator -> v_expr . plus v_expr
    (3) binary_operator -> v_expr . minus v_expr
    (4) binary_operator -> v_expr . star v_expr
    (5) binary_operator -> v_expr . div v_expr
    (29) comparison_expresion -> v_expr . less v_expr
    (30) comparison_expresion -> v_expr . less_equal v_expr
    (31) comparison_expresion -> v_expr . equal v_expr

    plus            reduce using rule 2 (binary_operator -> v_expr plus v_expr .)
    minus           reduce using rule 2 (binary_operator -> v_expr plus v_expr .)
    less            reduce using rule 2 (binary_operator -> v_expr plus v_expr .)
    less_equal      reduce using rule 2 (binary_operator -> v_expr plus v_expr .)
    equal           reduce using rule 2 (binary_operator -> v_expr plus v_expr .)
    semicolon       reduce using rule 2 (binary_operator -> v_expr plus v_expr .)
    idx             reduce using rule 2 (binary_operator -> v_expr plus v_expr .)
    inx             reduce using rule 2 (binary_operator -> v_expr plus v_expr .)
    loop            reduce using rule 2 (binary_operator -> v_expr plus v_expr .)
    cbracket        reduce using rule 2 (binary_operator -> v_expr plus v_expr .)
    then            reduce using rule 2 (binary_operator -> v_expr plus v_expr .)
    of              reduce using rule 2 (binary_operator -> v_expr plus v_expr .)
    ccurly          reduce using rule 2 (binary_operator -> v_expr plus v_expr .)
    pool            reduce using rule 2 (binary_operator -> v_expr plus v_expr .)
    else            reduce using rule 2 (binary_operator -> v_expr plus v_expr .)
    obracket        reduce using rule 2 (binary_operator -> v_expr plus v_expr .)
    if              reduce using rule 2 (binary_operator -> v_expr plus v_expr .)
    let             reduce using rule 2 (binary_operator -> v_expr plus v_expr .)
    case            reduce using rule 2 (binary_operator -> v_expr plus v_expr .)
    ocurly          reduce using rule 2 (binary_operator -> v_expr plus v_expr .)
    not             reduce using rule 2 (binary_operator -> v_expr plus v_expr .)
    complement      reduce using rule 2 (binary_operator -> v_expr plus v_expr .)
    isvoid          reduce using rule 2 (binary_operator -> v_expr plus v_expr .)
    new             reduce using rule 2 (binary_operator -> v_expr plus v_expr .)
    number          reduce using rule 2 (binary_operator -> v_expr plus v_expr .)
    string          reduce using rule 2 (binary_operator -> v_expr plus v_expr .)
    true            reduce using rule 2 (binary_operator -> v_expr plus v_expr .)
    false           reduce using rule 2 (binary_operator -> v_expr plus v_expr .)
    fi              reduce using rule 2 (binary_operator -> v_expr plus v_expr .)
    star            shift and go to state 88
    div             shift and go to state 89

  ! star            [ reduce using rule 2 (binary_operator -> v_expr plus v_expr .) ]
  ! div             [ reduce using rule 2 (binary_operator -> v_expr plus v_expr .) ]
  ! plus            [ shift and go to state 86 ]
  ! minus           [ shift and go to state 87 ]
  ! less            [ shift and go to state 90 ]
  ! less_equal      [ shift and go to state 91 ]
  ! equal           [ shift and go to state 92 ]


state 115

    (3) binary_operator -> v_expr minus v_expr .
    (2) binary_operator -> v_expr . plus v_expr
    (3) binary_operator -> v_expr . minus v_expr
    (4) binary_operator -> v_expr . star v_expr
    (5) binary_operator -> v_expr . div v_expr
    (29) comparison_expresion -> v_expr . less v_expr
    (30) comparison_expresion -> v_expr . less_equal v_expr
    (31) comparison_expresion -> v_expr . equal v_expr

    plus            reduce using rule 3 (binary_operator -> v_expr minus v_expr .)
    minus           reduce using rule 3 (binary_operator -> v_expr minus v_expr .)
    less            reduce using rule 3 (binary_operator -> v_expr minus v_expr .)
    less_equal      reduce using rule 3 (binary_operator -> v_expr minus v_expr .)
    equal           reduce using rule 3 (binary_operator -> v_expr minus v_expr .)
    semicolon       reduce using rule 3 (binary_operator -> v_expr minus v_expr .)
    idx             reduce using rule 3 (binary_operator -> v_expr minus v_expr .)
    inx             reduce using rule 3 (binary_operator -> v_expr minus v_expr .)
    loop            reduce using rule 3 (binary_operator -> v_expr minus v_expr .)
    cbracket        reduce using rule 3 (binary_operator -> v_expr minus v_expr .)
    then            reduce using rule 3 (binary_operator -> v_expr minus v_expr .)
    of              reduce using rule 3 (binary_operator -> v_expr minus v_expr .)
    ccurly          reduce using rule 3 (binary_operator -> v_expr minus v_expr .)
    pool            reduce using rule 3 (binary_operator -> v_expr minus v_expr .)
    else            reduce using rule 3 (binary_operator -> v_expr minus v_expr .)
    obracket        reduce using rule 3 (binary_operator -> v_expr minus v_expr .)
    if              reduce using rule 3 (binary_operator -> v_expr minus v_expr .)
    let             reduce using rule 3 (binary_operator -> v_expr minus v_expr .)
    case            reduce using rule 3 (binary_operator -> v_expr minus v_expr .)
    ocurly          reduce using rule 3 (binary_operator -> v_expr minus v_expr .)
    not             reduce using rule 3 (binary_operator -> v_expr minus v_expr .)
    complement      reduce using rule 3 (binary_operator -> v_expr minus v_expr .)
    isvoid          reduce using rule 3 (binary_operator -> v_expr minus v_expr .)
    new             reduce using rule 3 (binary_operator -> v_expr minus v_expr .)
    number          reduce using rule 3 (binary_operator -> v_expr minus v_expr .)
    string          reduce using rule 3 (binary_operator -> v_expr minus v_expr .)
    true            reduce using rule 3 (binary_operator -> v_expr minus v_expr .)
    false           reduce using rule 3 (binary_operator -> v_expr minus v_expr .)
    fi              reduce using rule 3 (binary_operator -> v_expr minus v_expr .)
    star            shift and go to state 88
    div             shift and go to state 89

  ! star            [ reduce using rule 3 (binary_operator -> v_expr minus v_expr .) ]
  ! div             [ reduce using rule 3 (binary_operator -> v_expr minus v_expr .) ]
  ! plus            [ shift and go to state 86 ]
  ! minus           [ shift and go to state 87 ]
  ! less            [ shift and go to state 90 ]
  ! less_equal      [ shift and go to state 91 ]
  ! equal           [ shift and go to state 92 ]


state 116

    (4) binary_operator -> v_expr star v_expr .
    (2) binary_operator -> v_expr . plus v_expr
    (3) binary_operator -> v_expr . minus v_expr
    (4) binary_operator -> v_expr . star v_expr
    (5) binary_operator -> v_expr . div v_expr
    (29) comparison_expresion -> v_expr . less v_expr
    (30) comparison_expresion -> v_expr . less_equal v_expr
    (31) comparison_expresion -> v_expr . equal v_expr

    plus            reduce using rule 4 (binary_operator -> v_expr star v_expr .)
    minus           reduce using rule 4 (binary_operator -> v_expr star v_expr .)
    star            reduce using rule 4 (binary_operator -> v_expr star v_expr .)
    div             reduce using rule 4 (binary_operator -> v_expr star v_expr .)
    less            reduce using rule 4 (binary_operator -> v_expr star v_expr .)
    less_equal      reduce using rule 4 (binary_operator -> v_expr star v_expr .)
    equal           reduce using rule 4 (binary_operator -> v_expr star v_expr .)
    semicolon       reduce using rule 4 (binary_operator -> v_expr star v_expr .)
    idx             reduce using rule 4 (binary_operator -> v_expr star v_expr .)
    inx             reduce using rule 4 (binary_operator -> v_expr star v_expr .)
    loop            reduce using rule 4 (binary_operator -> v_expr star v_expr .)
    cbracket        reduce using rule 4 (binary_operator -> v_expr star v_expr .)
    then            reduce using rule 4 (binary_operator -> v_expr star v_expr .)
    of              reduce using rule 4 (binary_operator -> v_expr star v_expr .)
    ccurly          reduce using rule 4 (binary_operator -> v_expr star v_expr .)
    pool            reduce using rule 4 (binary_operator -> v_expr star v_expr .)
    else            reduce using rule 4 (binary_operator -> v_expr star v_expr .)
    obracket        reduce using rule 4 (binary_operator -> v_expr star v_expr .)
    if              reduce using rule 4 (binary_operator -> v_expr star v_expr .)
    let             reduce using rule 4 (binary_operator -> v_expr star v_expr .)
    case            reduce using rule 4 (binary_operator -> v_expr star v_expr .)
    ocurly          reduce using rule 4 (binary_operator -> v_expr star v_expr .)
    not             reduce using rule 4 (binary_operator -> v_expr star v_expr .)
    complement      reduce using rule 4 (binary_operator -> v_expr star v_expr .)
    isvoid          reduce using rule 4 (binary_operator -> v_expr star v_expr .)
    new             reduce using rule 4 (binary_operator -> v_expr star v_expr .)
    number          reduce using rule 4 (binary_operator -> v_expr star v_expr .)
    string          reduce using rule 4 (binary_operator -> v_expr star v_expr .)
    true            reduce using rule 4 (binary_operator -> v_expr star v_expr .)
    false           reduce using rule 4 (binary_operator -> v_expr star v_expr .)
    fi              reduce using rule 4 (binary_operator -> v_expr star v_expr .)

  ! plus            [ shift and go to state 86 ]
  ! minus           [ shift and go to state 87 ]
  ! star            [ shift and go to state 88 ]
  ! div             [ shift and go to state 89 ]
  ! less            [ shift and go to state 90 ]
  ! less_equal      [ shift and go to state 91 ]
  ! equal           [ shift and go to state 92 ]


state 117

    (5) binary_operator -> v_expr div v_expr .
    (2) binary_operator -> v_expr . plus v_expr
    (3) binary_operator -> v_expr . minus v_expr
    (4) binary_operator -> v_expr . star v_expr
    (5) binary_operator -> v_expr . div v_expr
    (29) comparison_expresion -> v_expr . less v_expr
    (30) comparison_expresion -> v_expr . less_equal v_expr
    (31) comparison_expresion -> v_expr . equal v_expr

    plus            reduce using rule 5 (binary_operator -> v_expr div v_expr .)
    minus           reduce using rule 5 (binary_operator -> v_expr div v_expr .)
    star            reduce using rule 5 (binary_operator -> v_expr div v_expr .)
    div             reduce using rule 5 (binary_operator -> v_expr div v_expr .)
    less            reduce using rule 5 (binary_operator -> v_expr div v_expr .)
    less_equal      reduce using rule 5 (binary_operator -> v_expr div v_expr .)
    equal           reduce using rule 5 (binary_operator -> v_expr div v_expr .)
    semicolon       reduce using rule 5 (binary_operator -> v_expr div v_expr .)
    idx             reduce using rule 5 (binary_operator -> v_expr div v_expr .)
    inx             reduce using rule 5 (binary_operator -> v_expr div v_expr .)
    loop            reduce using rule 5 (binary_operator -> v_expr div v_expr .)
    cbracket        reduce using rule 5 (binary_operator -> v_expr div v_expr .)
    then            reduce using rule 5 (binary_operator -> v_expr div v_expr .)
    of              reduce using rule 5 (binary_operator -> v_expr div v_expr .)
    ccurly          reduce using rule 5 (binary_operator -> v_expr div v_expr .)
    pool            reduce using rule 5 (binary_operator -> v_expr div v_expr .)
    else            reduce using rule 5 (binary_operator -> v_expr div v_expr .)
    obracket        reduce using rule 5 (binary_operator -> v_expr div v_expr .)
    if              reduce using rule 5 (binary_operator -> v_expr div v_expr .)
    let             reduce using rule 5 (binary_operator -> v_expr div v_expr .)
    case            reduce using rule 5 (binary_operator -> v_expr div v_expr .)
    ocurly          reduce using rule 5 (binary_operator -> v_expr div v_expr .)
    not             reduce using rule 5 (binary_operator -> v_expr div v_expr .)
    complement      reduce using rule 5 (binary_operator -> v_expr div v_expr .)
    isvoid          reduce using rule 5 (binary_operator -> v_expr div v_expr .)
    new             reduce using rule 5 (binary_operator -> v_expr div v_expr .)
    number          reduce using rule 5 (binary_operator -> v_expr div v_expr .)
    string          reduce using rule 5 (binary_operator -> v_expr div v_expr .)
    true            reduce using rule 5 (binary_operator -> v_expr div v_expr .)
    false           reduce using rule 5 (binary_operator -> v_expr div v_expr .)
    fi              reduce using rule 5 (binary_operator -> v_expr div v_expr .)

  ! plus            [ shift and go to state 86 ]
  ! minus           [ shift and go to state 87 ]
  ! star            [ shift and go to state 88 ]
  ! div             [ shift and go to state 89 ]
  ! less            [ shift and go to state 90 ]
  ! less_equal      [ shift and go to state 91 ]
  ! equal           [ shift and go to state 92 ]


state 118

    (29) comparison_expresion -> v_expr less v_expr .
    (2) binary_operator -> v_expr . plus v_expr
    (3) binary_operator -> v_expr . minus v_expr
    (4) binary_operator -> v_expr . star v_expr
    (5) binary_operator -> v_expr . div v_expr
    (29) comparison_expresion -> v_expr . less v_expr
    (30) comparison_expresion -> v_expr . less_equal v_expr
    (31) comparison_expresion -> v_expr . equal v_expr

    less            reduce using rule 29 (comparison_expresion -> v_expr less v_expr .)
    less_equal      reduce using rule 29 (comparison_expresion -> v_expr less v_expr .)
    equal           reduce using rule 29 (comparison_expresion -> v_expr less v_expr .)
    semicolon       reduce using rule 29 (comparison_expresion -> v_expr less v_expr .)
    idx             reduce using rule 29 (comparison_expresion -> v_expr less v_expr .)
    inx             reduce using rule 29 (comparison_expresion -> v_expr less v_expr .)
    loop            reduce using rule 29 (comparison_expresion -> v_expr less v_expr .)
    cbracket        reduce using rule 29 (comparison_expresion -> v_expr less v_expr .)
    then            reduce using rule 29 (comparison_expresion -> v_expr less v_expr .)
    of              reduce using rule 29 (comparison_expresion -> v_expr less v_expr .)
    ccurly          reduce using rule 29 (comparison_expresion -> v_expr less v_expr .)
    pool            reduce using rule 29 (comparison_expresion -> v_expr less v_expr .)
    else            reduce using rule 29 (comparison_expresion -> v_expr less v_expr .)
    obracket        reduce using rule 29 (comparison_expresion -> v_expr less v_expr .)
    if              reduce using rule 29 (comparison_expresion -> v_expr less v_expr .)
    let             reduce using rule 29 (comparison_expresion -> v_expr less v_expr .)
    case            reduce using rule 29 (comparison_expresion -> v_expr less v_expr .)
    ocurly          reduce using rule 29 (comparison_expresion -> v_expr less v_expr .)
    not             reduce using rule 29 (comparison_expresion -> v_expr less v_expr .)
    complement      reduce using rule 29 (comparison_expresion -> v_expr less v_expr .)
    isvoid          reduce using rule 29 (comparison_expresion -> v_expr less v_expr .)
    new             reduce using rule 29 (comparison_expresion -> v_expr less v_expr .)
    number          reduce using rule 29 (comparison_expresion -> v_expr less v_expr .)
    string          reduce using rule 29 (comparison_expresion -> v_expr less v_expr .)
    true            reduce using rule 29 (comparison_expresion -> v_expr less v_expr .)
    false           reduce using rule 29 (comparison_expresion -> v_expr less v_expr .)
    fi              reduce using rule 29 (comparison_expresion -> v_expr less v_expr .)
    plus            shift and go to state 86
    minus           shift and go to state 87
    star            shift and go to state 88
    div             shift and go to state 89

  ! plus            [ reduce using rule 29 (comparison_expresion -> v_expr less v_expr .) ]
  ! minus           [ reduce using rule 29 (comparison_expresion -> v_expr less v_expr .) ]
  ! star            [ reduce using rule 29 (comparison_expresion -> v_expr less v_expr .) ]
  ! div             [ reduce using rule 29 (comparison_expresion -> v_expr less v_expr .) ]
  ! less            [ shift and go to state 90 ]
  ! less_equal      [ shift and go to state 91 ]
  ! equal           [ shift and go to state 92 ]


state 119

    (30) comparison_expresion -> v_expr less_equal v_expr .
    (2) binary_operator -> v_expr . plus v_expr
    (3) binary_operator -> v_expr . minus v_expr
    (4) binary_operator -> v_expr . star v_expr
    (5) binary_operator -> v_expr . div v_expr
    (29) comparison_expresion -> v_expr . less v_expr
    (30) comparison_expresion -> v_expr . less_equal v_expr
    (31) comparison_expresion -> v_expr . equal v_expr

    less            reduce using rule 30 (comparison_expresion -> v_expr less_equal v_expr .)
    less_equal      reduce using rule 30 (comparison_expresion -> v_expr less_equal v_expr .)
    equal           reduce using rule 30 (comparison_expresion -> v_expr less_equal v_expr .)
    semicolon       reduce using rule 30 (comparison_expresion -> v_expr less_equal v_expr .)
    idx             reduce using rule 30 (comparison_expresion -> v_expr less_equal v_expr .)
    inx             reduce using rule 30 (comparison_expresion -> v_expr less_equal v_expr .)
    loop            reduce using rule 30 (comparison_expresion -> v_expr less_equal v_expr .)
    cbracket        reduce using rule 30 (comparison_expresion -> v_expr less_equal v_expr .)
    then            reduce using rule 30 (comparison_expresion -> v_expr less_equal v_expr .)
    of              reduce using rule 30 (comparison_expresion -> v_expr less_equal v_expr .)
    ccurly          reduce using rule 30 (comparison_expresion -> v_expr less_equal v_expr .)
    pool            reduce using rule 30 (comparison_expresion -> v_expr less_equal v_expr .)
    else            reduce using rule 30 (comparison_expresion -> v_expr less_equal v_expr .)
    obracket        reduce using rule 30 (comparison_expresion -> v_expr less_equal v_expr .)
    if              reduce using rule 30 (comparison_expresion -> v_expr less_equal v_expr .)
    let             reduce using rule 30 (comparison_expresion -> v_expr less_equal v_expr .)
    case            reduce using rule 30 (comparison_expresion -> v_expr less_equal v_expr .)
    ocurly          reduce using rule 30 (comparison_expresion -> v_expr less_equal v_expr .)
    not             reduce using rule 30 (comparison_expresion -> v_expr less_equal v_expr .)
    complement      reduce using rule 30 (comparison_expresion -> v_expr less_equal v_expr .)
    isvoid          reduce using rule 30 (comparison_expresion -> v_expr less_equal v_expr .)
    new             reduce using rule 30 (comparison_expresion -> v_expr less_equal v_expr .)
    number          reduce using rule 30 (comparison_expresion -> v_expr less_equal v_expr .)
    string          reduce using rule 30 (comparison_expresion -> v_expr less_equal v_expr .)
    true            reduce using rule 30 (comparison_expresion -> v_expr less_equal v_expr .)
    false           reduce using rule 30 (comparison_expresion -> v_expr less_equal v_expr .)
    fi              reduce using rule 30 (comparison_expresion -> v_expr less_equal v_expr .)
    plus            shift and go to state 86
    minus           shift and go to state 87
    star            shift and go to state 88
    div             shift and go to state 89

  ! plus            [ reduce using rule 30 (comparison_expresion -> v_expr less_equal v_expr .) ]
  ! minus           [ reduce using rule 30 (comparison_expresion -> v_expr less_equal v_expr .) ]
  ! star            [ reduce using rule 30 (comparison_expresion -> v_expr less_equal v_expr .) ]
  ! div             [ reduce using rule 30 (comparison_expresion -> v_expr less_equal v_expr .) ]
  ! less            [ shift and go to state 90 ]
  ! less_equal      [ shift and go to state 91 ]
  ! equal           [ shift and go to state 92 ]


state 120

    (31) comparison_expresion -> v_expr equal v_expr .
    (2) binary_operator -> v_expr . plus v_expr
    (3) binary_operator -> v_expr . minus v_expr
    (4) binary_operator -> v_expr . star v_expr
    (5) binary_operator -> v_expr . div v_expr
    (29) comparison_expresion -> v_expr . less v_expr
    (30) comparison_expresion -> v_expr . less_equal v_expr
    (31) comparison_expresion -> v_expr . equal v_expr

    less            reduce using rule 31 (comparison_expresion -> v_expr equal v_expr .)
    less_equal      reduce using rule 31 (comparison_expresion -> v_expr equal v_expr .)
    equal           reduce using rule 31 (comparison_expresion -> v_expr equal v_expr .)
    semicolon       reduce using rule 31 (comparison_expresion -> v_expr equal v_expr .)
    idx             reduce using rule 31 (comparison_expresion -> v_expr equal v_expr .)
    inx             reduce using rule 31 (comparison_expresion -> v_expr equal v_expr .)
    loop            reduce using rule 31 (comparison_expresion -> v_expr equal v_expr .)
    cbracket        reduce using rule 31 (comparison_expresion -> v_expr equal v_expr .)
    then            reduce using rule 31 (comparison_expresion -> v_expr equal v_expr .)
    of              reduce using rule 31 (comparison_expresion -> v_expr equal v_expr .)
    ccurly          reduce using rule 31 (comparison_expresion -> v_expr equal v_expr .)
    pool            reduce using rule 31 (comparison_expresion -> v_expr equal v_expr .)
    else            reduce using rule 31 (comparison_expresion -> v_expr equal v_expr .)
    obracket        reduce using rule 31 (comparison_expresion -> v_expr equal v_expr .)
    if              reduce using rule 31 (comparison_expresion -> v_expr equal v_expr .)
    let             reduce using rule 31 (comparison_expresion -> v_expr equal v_expr .)
    case            reduce using rule 31 (comparison_expresion -> v_expr equal v_expr .)
    ocurly          reduce using rule 31 (comparison_expresion -> v_expr equal v_expr .)
    not             reduce using rule 31 (comparison_expresion -> v_expr equal v_expr .)
    complement      reduce using rule 31 (comparison_expresion -> v_expr equal v_expr .)
    isvoid          reduce using rule 31 (comparison_expresion -> v_expr equal v_expr .)
    new             reduce using rule 31 (comparison_expresion -> v_expr equal v_expr .)
    number          reduce using rule 31 (comparison_expresion -> v_expr equal v_expr .)
    string          reduce using rule 31 (comparison_expresion -> v_expr equal v_expr .)
    true            reduce using rule 31 (comparison_expresion -> v_expr equal v_expr .)
    false           reduce using rule 31 (comparison_expresion -> v_expr equal v_expr .)
    fi              reduce using rule 31 (comparison_expresion -> v_expr equal v_expr .)
    plus            shift and go to state 86
    minus           shift and go to state 87
    star            shift and go to state 88
    div             shift and go to state 89

  ! plus            [ reduce using rule 31 (comparison_expresion -> v_expr equal v_expr .) ]
  ! minus           [ reduce using rule 31 (comparison_expresion -> v_expr equal v_expr .) ]
  ! star            [ reduce using rule 31 (comparison_expresion -> v_expr equal v_expr .) ]
  ! div             [ reduce using rule 31 (comparison_expresion -> v_expr equal v_expr .) ]
  ! less            [ shift and go to state 90 ]
  ! less_equal      [ shift and go to state 91 ]
  ! equal           [ shift and go to state 92 ]


state 121

    (62) while_expresion -> while v_expr loop . expr pool
    (26) expr -> . assign_expresion
    (27) expr -> . while_expresion
    (28) expr -> . v_expr
    (11) assign_expresion -> . idx assign expr
    (62) while_expresion -> . while v_expr loop expr pool
    (32) v_expr -> . conditional_expresion
    (33) v_expr -> . let_expresion
    (34) v_expr -> . case_expresion
    (35) v_expr -> . dispatch_expresion
    (36) v_expr -> . dispatch_instance
    (37) v_expr -> . block_expresion
    (38) v_expr -> . binary_operator
    (39) v_expr -> . neg
    (40) v_expr -> . compl
    (41) v_expr -> . is_void
    (42) v_expr -> . new_expresion
    (43) v_expr -> . obracket v_expr cbracket
    (44) v_expr -> . term
    (45) v_expr -> . comparison_expresion
    (60) conditional_expresion -> . if v_expr then expr else expr fi
    (67) let_expresion -> . let let_declr_list inx expr
    (63) case_expresion -> . case expr of case_list esac
    (71) dispatch_expresion -> . idx obracket dispatch_p_list cbracket
    (72) dispatch_instance -> . idx dot idx obracket dispatch_p_list cbracket
    (73) dispatch_instance -> . idx arrobe idx dot idx obracket dispatch_p_list cbracket
    (55) block_expresion -> . ocurly block_expr ccurly
    (2) binary_operator -> . v_expr plus v_expr
    (3) binary_operator -> . v_expr minus v_expr
    (4) binary_operator -> . v_expr star v_expr
    (5) binary_operator -> . v_expr div v_expr
    (9) neg -> . not idx
    (10) compl -> . complement idx
    (61) is_void -> . isvoid expr
    (15) new_expresion -> . new idx
    (46) term -> . var
    (47) term -> . num
    (48) term -> . str
    (49) term -> . bool
    (29) comparison_expresion -> . v_expr less v_expr
    (30) comparison_expresion -> . v_expr less_equal v_expr
    (31) comparison_expresion -> . v_expr equal v_expr
    (50) var -> . idx
    (51) num -> . number
    (52) str -> . string
    (53) bool -> . true
    (54) bool -> . false

    idx             shift and go to state 44
    while           shift and go to state 49
    obracket        shift and go to state 61
    if              shift and go to state 64
    let             shift and go to state 65
    case            shift and go to state 66
    ocurly          shift and go to state 67
    not             shift and go to state 68
    complement      shift and go to state 69
    isvoid          shift and go to state 70
    new             shift and go to state 71
    number          shift and go to state 76
    string          shift and go to state 77
    true            shift and go to state 78
    false           shift and go to state 79

    v_expr                         shift and go to state 48
    expr                           shift and go to state 136
    assign_expresion               shift and go to state 46
    while_expresion                shift and go to state 47
    conditional_expresion          shift and go to state 50
    let_expresion                  shift and go to state 51
    case_expresion                 shift and go to state 52
    dispatch_expresion             shift and go to state 53
    dispatch_instance              shift and go to state 54
    block_expresion                shift and go to state 55
    binary_operator                shift and go to state 56
    neg                            shift and go to state 57
    compl                          shift and go to state 58
    is_void                        shift and go to state 59
    new_expresion                  shift and go to state 60
    term                           shift and go to state 62
    comparison_expresion           shift and go to state 63
    var                            shift and go to state 72
    num                            shift and go to state 73
    str                            shift and go to state 74
    bool                           shift and go to state 75

state 122

    (43) v_expr -> obracket v_expr cbracket .

    plus            reduce using rule 43 (v_expr -> obracket v_expr cbracket .)
    minus           reduce using rule 43 (v_expr -> obracket v_expr cbracket .)
    star            reduce using rule 43 (v_expr -> obracket v_expr cbracket .)
    div             reduce using rule 43 (v_expr -> obracket v_expr cbracket .)
    less            reduce using rule 43 (v_expr -> obracket v_expr cbracket .)
    less_equal      reduce using rule 43 (v_expr -> obracket v_expr cbracket .)
    equal           reduce using rule 43 (v_expr -> obracket v_expr cbracket .)
    semicolon       reduce using rule 43 (v_expr -> obracket v_expr cbracket .)
    idx             reduce using rule 43 (v_expr -> obracket v_expr cbracket .)
    inx             reduce using rule 43 (v_expr -> obracket v_expr cbracket .)
    loop            reduce using rule 43 (v_expr -> obracket v_expr cbracket .)
    cbracket        reduce using rule 43 (v_expr -> obracket v_expr cbracket .)
    then            reduce using rule 43 (v_expr -> obracket v_expr cbracket .)
    of              reduce using rule 43 (v_expr -> obracket v_expr cbracket .)
    ccurly          reduce using rule 43 (v_expr -> obracket v_expr cbracket .)
    pool            reduce using rule 43 (v_expr -> obracket v_expr cbracket .)
    else            reduce using rule 43 (v_expr -> obracket v_expr cbracket .)
    obracket        reduce using rule 43 (v_expr -> obracket v_expr cbracket .)
    if              reduce using rule 43 (v_expr -> obracket v_expr cbracket .)
    let             reduce using rule 43 (v_expr -> obracket v_expr cbracket .)
    case            reduce using rule 43 (v_expr -> obracket v_expr cbracket .)
    ocurly          reduce using rule 43 (v_expr -> obracket v_expr cbracket .)
    not             reduce using rule 43 (v_expr -> obracket v_expr cbracket .)
    complement      reduce using rule 43 (v_expr -> obracket v_expr cbracket .)
    isvoid          reduce using rule 43 (v_expr -> obracket v_expr cbracket .)
    new             reduce using rule 43 (v_expr -> obracket v_expr cbracket .)
    number          reduce using rule 43 (v_expr -> obracket v_expr cbracket .)
    string          reduce using rule 43 (v_expr -> obracket v_expr cbracket .)
    true            reduce using rule 43 (v_expr -> obracket v_expr cbracket .)
    false           reduce using rule 43 (v_expr -> obracket v_expr cbracket .)
    fi              reduce using rule 43 (v_expr -> obracket v_expr cbracket .)


state 123

    (60) conditional_expresion -> if v_expr then . expr else expr fi
    (26) expr -> . assign_expresion
    (27) expr -> . while_expresion
    (28) expr -> . v_expr
    (11) assign_expresion -> . idx assign expr
    (62) while_expresion -> . while v_expr loop expr pool
    (32) v_expr -> . conditional_expresion
    (33) v_expr -> . let_expresion
    (34) v_expr -> . case_expresion
    (35) v_expr -> . dispatch_expresion
    (36) v_expr -> . dispatch_instance
    (37) v_expr -> . block_expresion
    (38) v_expr -> . binary_operator
    (39) v_expr -> . neg
    (40) v_expr -> . compl
    (41) v_expr -> . is_void
    (42) v_expr -> . new_expresion
    (43) v_expr -> . obracket v_expr cbracket
    (44) v_expr -> . term
    (45) v_expr -> . comparison_expresion
    (60) conditional_expresion -> . if v_expr then expr else expr fi
    (67) let_expresion -> . let let_declr_list inx expr
    (63) case_expresion -> . case expr of case_list esac
    (71) dispatch_expresion -> . idx obracket dispatch_p_list cbracket
    (72) dispatch_instance -> . idx dot idx obracket dispatch_p_list cbracket
    (73) dispatch_instance -> . idx arrobe idx dot idx obracket dispatch_p_list cbracket
    (55) block_expresion -> . ocurly block_expr ccurly
    (2) binary_operator -> . v_expr plus v_expr
    (3) binary_operator -> . v_expr minus v_expr
    (4) binary_operator -> . v_expr star v_expr
    (5) binary_operator -> . v_expr div v_expr
    (9) neg -> . not idx
    (10) compl -> . complement idx
    (61) is_void -> . isvoid expr
    (15) new_expresion -> . new idx
    (46) term -> . var
    (47) term -> . num
    (48) term -> . str
    (49) term -> . bool
    (29) comparison_expresion -> . v_expr less v_expr
    (30) comparison_expresion -> . v_expr less_equal v_expr
    (31) comparison_expresion -> . v_expr equal v_expr
    (50) var -> . idx
    (51) num -> . number
    (52) str -> . string
    (53) bool -> . true
    (54) bool -> . false

    idx             shift and go to state 44
    while           shift and go to state 49
    obracket        shift and go to state 61
    if              shift and go to state 64
    let             shift and go to state 65
    case            shift and go to state 66
    ocurly          shift and go to state 67
    not             shift and go to state 68
    complement      shift and go to state 69
    isvoid          shift and go to state 70
    new             shift and go to state 71
    number          shift and go to state 76
    string          shift and go to state 77
    true            shift and go to state 78
    false           shift and go to state 79

    v_expr                         shift and go to state 48
    expr                           shift and go to state 137
    assign_expresion               shift and go to state 46
    while_expresion                shift and go to state 47
    conditional_expresion          shift and go to state 50
    let_expresion                  shift and go to state 51
    case_expresion                 shift and go to state 52
    dispatch_expresion             shift and go to state 53
    dispatch_instance              shift and go to state 54
    block_expresion                shift and go to state 55
    binary_operator                shift and go to state 56
    neg                            shift and go to state 57
    compl                          shift and go to state 58
    is_void                        shift and go to state 59
    new_expresion                  shift and go to state 60
    term                           shift and go to state 62
    comparison_expresion           shift and go to state 63
    var                            shift and go to state 72
    num                            shift and go to state 73
    str                            shift and go to state 74
    bool                           shift and go to state 75

state 124

    (67) let_expresion -> let let_declr_list inx . expr
    (26) expr -> . assign_expresion
    (27) expr -> . while_expresion
    (28) expr -> . v_expr
    (11) assign_expresion -> . idx assign expr
    (62) while_expresion -> . while v_expr loop expr pool
    (32) v_expr -> . conditional_expresion
    (33) v_expr -> . let_expresion
    (34) v_expr -> . case_expresion
    (35) v_expr -> . dispatch_expresion
    (36) v_expr -> . dispatch_instance
    (37) v_expr -> . block_expresion
    (38) v_expr -> . binary_operator
    (39) v_expr -> . neg
    (40) v_expr -> . compl
    (41) v_expr -> . is_void
    (42) v_expr -> . new_expresion
    (43) v_expr -> . obracket v_expr cbracket
    (44) v_expr -> . term
    (45) v_expr -> . comparison_expresion
    (60) conditional_expresion -> . if v_expr then expr else expr fi
    (67) let_expresion -> . let let_declr_list inx expr
    (63) case_expresion -> . case expr of case_list esac
    (71) dispatch_expresion -> . idx obracket dispatch_p_list cbracket
    (72) dispatch_instance -> . idx dot idx obracket dispatch_p_list cbracket
    (73) dispatch_instance -> . idx arrobe idx dot idx obracket dispatch_p_list cbracket
    (55) block_expresion -> . ocurly block_expr ccurly
    (2) binary_operator -> . v_expr plus v_expr
    (3) binary_operator -> . v_expr minus v_expr
    (4) binary_operator -> . v_expr star v_expr
    (5) binary_operator -> . v_expr div v_expr
    (9) neg -> . not idx
    (10) compl -> . complement idx
    (61) is_void -> . isvoid expr
    (15) new_expresion -> . new idx
    (46) term -> . var
    (47) term -> . num
    (48) term -> . str
    (49) term -> . bool
    (29) comparison_expresion -> . v_expr less v_expr
    (30) comparison_expresion -> . v_expr less_equal v_expr
    (31) comparison_expresion -> . v_expr equal v_expr
    (50) var -> . idx
    (51) num -> . number
    (52) str -> . string
    (53) bool -> . true
    (54) bool -> . false

    idx             shift and go to state 44
    while           shift and go to state 49
    obracket        shift and go to state 61
    if              shift and go to state 64
    let             shift and go to state 65
    case            shift and go to state 66
    ocurly          shift and go to state 67
    not             shift and go to state 68
    complement      shift and go to state 69
    isvoid          shift and go to state 70
    new             shift and go to state 71
    number          shift and go to state 76
    string          shift and go to state 77
    true            shift and go to state 78
    false           shift and go to state 79

    expr                           shift and go to state 138
    assign_expresion               shift and go to state 46
    while_expresion                shift and go to state 47
    v_expr                         shift and go to state 48
    conditional_expresion          shift and go to state 50
    let_expresion                  shift and go to state 51
    case_expresion                 shift and go to state 52
    dispatch_expresion             shift and go to state 53
    dispatch_instance              shift and go to state 54
    block_expresion                shift and go to state 55
    binary_operator                shift and go to state 56
    neg                            shift and go to state 57
    compl                          shift and go to state 58
    is_void                        shift and go to state 59
    new_expresion                  shift and go to state 60
    term                           shift and go to state 62
    comparison_expresion           shift and go to state 63
    var                            shift and go to state 72
    num                            shift and go to state 73
    str                            shift and go to state 74
    bool                           shift and go to state 75

state 125

    (69) let_declr_list_a -> declare_expresion . let_declr_list_a
    (69) let_declr_list_a -> . declare_expresion let_declr_list_a
    (70) let_declr_list_a -> . empty
    (12) declare_expresion -> . idx doubledot idx assign expr
    (13) declare_expresion -> . idx doubledot idx
    (1) empty -> .

    idx             shift and go to state 99
    inx             reduce using rule 1 (empty -> .)

    declare_expresion              shift and go to state 125
    let_declr_list_a               shift and go to state 139
    empty                          shift and go to state 127

state 126

    (68) let_declr_list -> declare_expresion let_declr_list_a .

    inx             reduce using rule 68 (let_declr_list -> declare_expresion let_declr_list_a .)


state 127

    (70) let_declr_list_a -> empty .

    inx             reduce using rule 70 (let_declr_list_a -> empty .)


state 128

    (63) case_expresion -> case expr of . case_list esac
    (64) case_list -> . declare_method case_expr expr semicolon case_list_a
    (14) declare_method -> . idx doubledot idx

    idx             shift and go to state 29

    case_list                      shift and go to state 140
    declare_method                 shift and go to state 141

state 129

    (55) block_expresion -> ocurly block_expr ccurly .

    plus            reduce using rule 55 (block_expresion -> ocurly block_expr ccurly .)
    minus           reduce using rule 55 (block_expresion -> ocurly block_expr ccurly .)
    star            reduce using rule 55 (block_expresion -> ocurly block_expr ccurly .)
    div             reduce using rule 55 (block_expresion -> ocurly block_expr ccurly .)
    less            reduce using rule 55 (block_expresion -> ocurly block_expr ccurly .)
    less_equal      reduce using rule 55 (block_expresion -> ocurly block_expr ccurly .)
    equal           reduce using rule 55 (block_expresion -> ocurly block_expr ccurly .)
    semicolon       reduce using rule 55 (block_expresion -> ocurly block_expr ccurly .)
    idx             reduce using rule 55 (block_expresion -> ocurly block_expr ccurly .)
    inx             reduce using rule 55 (block_expresion -> ocurly block_expr ccurly .)
    loop            reduce using rule 55 (block_expresion -> ocurly block_expr ccurly .)
    cbracket        reduce using rule 55 (block_expresion -> ocurly block_expr ccurly .)
    then            reduce using rule 55 (block_expresion -> ocurly block_expr ccurly .)
    of              reduce using rule 55 (block_expresion -> ocurly block_expr ccurly .)
    ccurly          reduce using rule 55 (block_expresion -> ocurly block_expr ccurly .)
    pool            reduce using rule 55 (block_expresion -> ocurly block_expr ccurly .)
    else            reduce using rule 55 (block_expresion -> ocurly block_expr ccurly .)
    obracket        reduce using rule 55 (block_expresion -> ocurly block_expr ccurly .)
    if              reduce using rule 55 (block_expresion -> ocurly block_expr ccurly .)
    let             reduce using rule 55 (block_expresion -> ocurly block_expr ccurly .)
    case            reduce using rule 55 (block_expresion -> ocurly block_expr ccurly .)
    ocurly          reduce using rule 55 (block_expresion -> ocurly block_expr ccurly .)
    not             reduce using rule 55 (block_expresion -> ocurly block_expr ccurly .)
    complement      reduce using rule 55 (block_expresion -> ocurly block_expr ccurly .)
    isvoid          reduce using rule 55 (block_expresion -> ocurly block_expr ccurly .)
    new             reduce using rule 55 (block_expresion -> ocurly block_expr ccurly .)
    number          reduce using rule 55 (block_expresion -> ocurly block_expr ccurly .)
    string          reduce using rule 55 (block_expresion -> ocurly block_expr ccurly .)
    true            reduce using rule 55 (block_expresion -> ocurly block_expr ccurly .)
    false           reduce using rule 55 (block_expresion -> ocurly block_expr ccurly .)
    fi              reduce using rule 55 (block_expresion -> ocurly block_expr ccurly .)


state 130

    (56) block_expr -> expr semicolon . block_expr_a
    (57) block_expr_a -> . expr semicolon block_expr_a
    (58) block_expr_a -> . empty
    (26) expr -> . assign_expresion
    (27) expr -> . while_expresion
    (28) expr -> . v_expr
    (1) empty -> .
    (11) assign_expresion -> . idx assign expr
    (62) while_expresion -> . while v_expr loop expr pool
    (32) v_expr -> . conditional_expresion
    (33) v_expr -> . let_expresion
    (34) v_expr -> . case_expresion
    (35) v_expr -> . dispatch_expresion
    (36) v_expr -> . dispatch_instance
    (37) v_expr -> . block_expresion
    (38) v_expr -> . binary_operator
    (39) v_expr -> . neg
    (40) v_expr -> . compl
    (41) v_expr -> . is_void
    (42) v_expr -> . new_expresion
    (43) v_expr -> . obracket v_expr cbracket
    (44) v_expr -> . term
    (45) v_expr -> . comparison_expresion
    (60) conditional_expresion -> . if v_expr then expr else expr fi
    (67) let_expresion -> . let let_declr_list inx expr
    (63) case_expresion -> . case expr of case_list esac
    (71) dispatch_expresion -> . idx obracket dispatch_p_list cbracket
    (72) dispatch_instance -> . idx dot idx obracket dispatch_p_list cbracket
    (73) dispatch_instance -> . idx arrobe idx dot idx obracket dispatch_p_list cbracket
    (55) block_expresion -> . ocurly block_expr ccurly
    (2) binary_operator -> . v_expr plus v_expr
    (3) binary_operator -> . v_expr minus v_expr
    (4) binary_operator -> . v_expr star v_expr
    (5) binary_operator -> . v_expr div v_expr
    (9) neg -> . not idx
    (10) compl -> . complement idx
    (61) is_void -> . isvoid expr
    (15) new_expresion -> . new idx
    (46) term -> . var
    (47) term -> . num
    (48) term -> . str
    (49) term -> . bool
    (29) comparison_expresion -> . v_expr less v_expr
    (30) comparison_expresion -> . v_expr less_equal v_expr
    (31) comparison_expresion -> . v_expr equal v_expr
    (50) var -> . idx
    (51) num -> . number
    (52) str -> . string
    (53) bool -> . true
    (54) bool -> . false

    ccurly          reduce using rule 1 (empty -> .)
    idx             shift and go to state 44
    while           shift and go to state 49
    obracket        shift and go to state 61
    if              shift and go to state 64
    let             shift and go to state 65
    case            shift and go to state 66
    ocurly          shift and go to state 67
    not             shift and go to state 68
    complement      shift and go to state 69
    isvoid          shift and go to state 70
    new             shift and go to state 71
    number          shift and go to state 76
    string          shift and go to state 77
    true            shift and go to state 78
    false           shift and go to state 79

    expr                           shift and go to state 142
    block_expr_a                   shift and go to state 143
    empty                          shift and go to state 144
    assign_expresion               shift and go to state 46
    while_expresion                shift and go to state 47
    v_expr                         shift and go to state 48
    conditional_expresion          shift and go to state 50
    let_expresion                  shift and go to state 51
    case_expresion                 shift and go to state 52
    dispatch_expresion             shift and go to state 53
    dispatch_instance              shift and go to state 54
    block_expresion                shift and go to state 55
    binary_operator                shift and go to state 56
    neg                            shift and go to state 57
    compl                          shift and go to state 58
    is_void                        shift and go to state 59
    new_expresion                  shift and go to state 60
    term                           shift and go to state 62
    comparison_expresion           shift and go to state 63
    var                            shift and go to state 72
    num                            shift and go to state 73
    str                            shift and go to state 74
    bool                           shift and go to state 75

state 131

    (21) method_decl -> idx obracket formal cbracket doubledot idx ocurly expr . ccurly semicolon feature

    ccurly          shift and go to state 145


state 132

    (71) dispatch_expresion -> idx obracket dispatch_p_list cbracket .

    plus            reduce using rule 71 (dispatch_expresion -> idx obracket dispatch_p_list cbracket .)
    minus           reduce using rule 71 (dispatch_expresion -> idx obracket dispatch_p_list cbracket .)
    star            reduce using rule 71 (dispatch_expresion -> idx obracket dispatch_p_list cbracket .)
    div             reduce using rule 71 (dispatch_expresion -> idx obracket dispatch_p_list cbracket .)
    less            reduce using rule 71 (dispatch_expresion -> idx obracket dispatch_p_list cbracket .)
    less_equal      reduce using rule 71 (dispatch_expresion -> idx obracket dispatch_p_list cbracket .)
    equal           reduce using rule 71 (dispatch_expresion -> idx obracket dispatch_p_list cbracket .)
    semicolon       reduce using rule 71 (dispatch_expresion -> idx obracket dispatch_p_list cbracket .)
    idx             reduce using rule 71 (dispatch_expresion -> idx obracket dispatch_p_list cbracket .)
    inx             reduce using rule 71 (dispatch_expresion -> idx obracket dispatch_p_list cbracket .)
    loop            reduce using rule 71 (dispatch_expresion -> idx obracket dispatch_p_list cbracket .)
    cbracket        reduce using rule 71 (dispatch_expresion -> idx obracket dispatch_p_list cbracket .)
    then            reduce using rule 71 (dispatch_expresion -> idx obracket dispatch_p_list cbracket .)
    of              reduce using rule 71 (dispatch_expresion -> idx obracket dispatch_p_list cbracket .)
    ccurly          reduce using rule 71 (dispatch_expresion -> idx obracket dispatch_p_list cbracket .)
    pool            reduce using rule 71 (dispatch_expresion -> idx obracket dispatch_p_list cbracket .)
    else            reduce using rule 71 (dispatch_expresion -> idx obracket dispatch_p_list cbracket .)
    obracket        reduce using rule 71 (dispatch_expresion -> idx obracket dispatch_p_list cbracket .)
    if              reduce using rule 71 (dispatch_expresion -> idx obracket dispatch_p_list cbracket .)
    let             reduce using rule 71 (dispatch_expresion -> idx obracket dispatch_p_list cbracket .)
    case            reduce using rule 71 (dispatch_expresion -> idx obracket dispatch_p_list cbracket .)
    ocurly          reduce using rule 71 (dispatch_expresion -> idx obracket dispatch_p_list cbracket .)
    not             reduce using rule 71 (dispatch_expresion -> idx obracket dispatch_p_list cbracket .)
    complement      reduce using rule 71 (dispatch_expresion -> idx obracket dispatch_p_list cbracket .)
    isvoid          reduce using rule 71 (dispatch_expresion -> idx obracket dispatch_p_list cbracket .)
    new             reduce using rule 71 (dispatch_expresion -> idx obracket dispatch_p_list cbracket .)
    number          reduce using rule 71 (dispatch_expresion -> idx obracket dispatch_p_list cbracket .)
    string          reduce using rule 71 (dispatch_expresion -> idx obracket dispatch_p_list cbracket .)
    true            reduce using rule 71 (dispatch_expresion -> idx obracket dispatch_p_list cbracket .)
    false           reduce using rule 71 (dispatch_expresion -> idx obracket dispatch_p_list cbracket .)
    fi              reduce using rule 71 (dispatch_expresion -> idx obracket dispatch_p_list cbracket .)


state 133

    (74) dispatch_p_list -> v_expr dispatch_p_list .

    cbracket        reduce using rule 74 (dispatch_p_list -> v_expr dispatch_p_list .)


state 134

    (72) dispatch_instance -> idx dot idx obracket . dispatch_p_list cbracket
    (74) dispatch_p_list -> . v_expr dispatch_p_list
    (75) dispatch_p_list -> . empty
    (32) v_expr -> . conditional_expresion
    (33) v_expr -> . let_expresion
    (34) v_expr -> . case_expresion
    (35) v_expr -> . dispatch_expresion
    (36) v_expr -> . dispatch_instance
    (37) v_expr -> . block_expresion
    (38) v_expr -> . binary_operator
    (39) v_expr -> . neg
    (40) v_expr -> . compl
    (41) v_expr -> . is_void
    (42) v_expr -> . new_expresion
    (43) v_expr -> . obracket v_expr cbracket
    (44) v_expr -> . term
    (45) v_expr -> . comparison_expresion
    (1) empty -> .
    (60) conditional_expresion -> . if v_expr then expr else expr fi
    (67) let_expresion -> . let let_declr_list inx expr
    (63) case_expresion -> . case expr of case_list esac
    (71) dispatch_expresion -> . idx obracket dispatch_p_list cbracket
    (72) dispatch_instance -> . idx dot idx obracket dispatch_p_list cbracket
    (73) dispatch_instance -> . idx arrobe idx dot idx obracket dispatch_p_list cbracket
    (55) block_expresion -> . ocurly block_expr ccurly
    (2) binary_operator -> . v_expr plus v_expr
    (3) binary_operator -> . v_expr minus v_expr
    (4) binary_operator -> . v_expr star v_expr
    (5) binary_operator -> . v_expr div v_expr
    (9) neg -> . not idx
    (10) compl -> . complement idx
    (61) is_void -> . isvoid expr
    (15) new_expresion -> . new idx
    (46) term -> . var
    (47) term -> . num
    (48) term -> . str
    (49) term -> . bool
    (29) comparison_expresion -> . v_expr less v_expr
    (30) comparison_expresion -> . v_expr less_equal v_expr
    (31) comparison_expresion -> . v_expr equal v_expr
    (50) var -> . idx
    (51) num -> . number
    (52) str -> . string
    (53) bool -> . true
    (54) bool -> . false

    obracket        shift and go to state 61
    cbracket        reduce using rule 1 (empty -> .)
    if              shift and go to state 64
    let             shift and go to state 65
    case            shift and go to state 66
    idx             shift and go to state 94
    ocurly          shift and go to state 67
    not             shift and go to state 68
    complement      shift and go to state 69
    isvoid          shift and go to state 70
    new             shift and go to state 71
    number          shift and go to state 76
    string          shift and go to state 77
    true            shift and go to state 78
    false           shift and go to state 79

    dispatch_p_list                shift and go to state 146
    v_expr                         shift and go to state 110
    empty                          shift and go to state 111
    conditional_expresion          shift and go to state 50
    let_expresion                  shift and go to state 51
    case_expresion                 shift and go to state 52
    dispatch_expresion             shift and go to state 53
    dispatch_instance              shift and go to state 54
    block_expresion                shift and go to state 55
    binary_operator                shift and go to state 56
    neg                            shift and go to state 57
    compl                          shift and go to state 58
    is_void                        shift and go to state 59
    new_expresion                  shift and go to state 60
    term                           shift and go to state 62
    comparison_expresion           shift and go to state 63
    var                            shift and go to state 72
    num                            shift and go to state 73
    str                            shift and go to state 74
    bool                           shift and go to state 75

state 135

    (73) dispatch_instance -> idx arrobe idx dot . idx obracket dispatch_p_list cbracket

    idx             shift and go to state 147


state 136

    (62) while_expresion -> while v_expr loop expr . pool

    pool            shift and go to state 148


state 137

    (60) conditional_expresion -> if v_expr then expr . else expr fi

    else            shift and go to state 149


state 138

    (67) let_expresion -> let let_declr_list inx expr .

    plus            reduce using rule 67 (let_expresion -> let let_declr_list inx expr .)
    minus           reduce using rule 67 (let_expresion -> let let_declr_list inx expr .)
    star            reduce using rule 67 (let_expresion -> let let_declr_list inx expr .)
    div             reduce using rule 67 (let_expresion -> let let_declr_list inx expr .)
    less            reduce using rule 67 (let_expresion -> let let_declr_list inx expr .)
    less_equal      reduce using rule 67 (let_expresion -> let let_declr_list inx expr .)
    equal           reduce using rule 67 (let_expresion -> let let_declr_list inx expr .)
    semicolon       reduce using rule 67 (let_expresion -> let let_declr_list inx expr .)
    idx             reduce using rule 67 (let_expresion -> let let_declr_list inx expr .)
    inx             reduce using rule 67 (let_expresion -> let let_declr_list inx expr .)
    loop            reduce using rule 67 (let_expresion -> let let_declr_list inx expr .)
    cbracket        reduce using rule 67 (let_expresion -> let let_declr_list inx expr .)
    then            reduce using rule 67 (let_expresion -> let let_declr_list inx expr .)
    of              reduce using rule 67 (let_expresion -> let let_declr_list inx expr .)
    ccurly          reduce using rule 67 (let_expresion -> let let_declr_list inx expr .)
    pool            reduce using rule 67 (let_expresion -> let let_declr_list inx expr .)
    else            reduce using rule 67 (let_expresion -> let let_declr_list inx expr .)
    obracket        reduce using rule 67 (let_expresion -> let let_declr_list inx expr .)
    if              reduce using rule 67 (let_expresion -> let let_declr_list inx expr .)
    let             reduce using rule 67 (let_expresion -> let let_declr_list inx expr .)
    case            reduce using rule 67 (let_expresion -> let let_declr_list inx expr .)
    ocurly          reduce using rule 67 (let_expresion -> let let_declr_list inx expr .)
    not             reduce using rule 67 (let_expresion -> let let_declr_list inx expr .)
    complement      reduce using rule 67 (let_expresion -> let let_declr_list inx expr .)
    isvoid          reduce using rule 67 (let_expresion -> let let_declr_list inx expr .)
    new             reduce using rule 67 (let_expresion -> let let_declr_list inx expr .)
    number          reduce using rule 67 (let_expresion -> let let_declr_list inx expr .)
    string          reduce using rule 67 (let_expresion -> let let_declr_list inx expr .)
    true            reduce using rule 67 (let_expresion -> let let_declr_list inx expr .)
    false           reduce using rule 67 (let_expresion -> let let_declr_list inx expr .)
    fi              reduce using rule 67 (let_expresion -> let let_declr_list inx expr .)


state 139

    (69) let_declr_list_a -> declare_expresion let_declr_list_a .

    inx             reduce using rule 69 (let_declr_list_a -> declare_expresion let_declr_list_a .)


state 140

    (63) case_expresion -> case expr of case_list . esac

    esac            shift and go to state 150


state 141

    (64) case_list -> declare_method . case_expr expr semicolon case_list_a

    case_expr       shift and go to state 151


state 142

    (57) block_expr_a -> expr . semicolon block_expr_a

    semicolon       shift and go to state 152


state 143

    (56) block_expr -> expr semicolon block_expr_a .

    ccurly          reduce using rule 56 (block_expr -> expr semicolon block_expr_a .)


state 144

    (58) block_expr_a -> empty .

    ccurly          reduce using rule 58 (block_expr_a -> empty .)


state 145

    (21) method_decl -> idx obracket formal cbracket doubledot idx ocurly expr ccurly . semicolon feature

    semicolon       shift and go to state 153


state 146

    (72) dispatch_instance -> idx dot idx obracket dispatch_p_list . cbracket

    cbracket        shift and go to state 154


state 147

    (73) dispatch_instance -> idx arrobe idx dot idx . obracket dispatch_p_list cbracket

    obracket        shift and go to state 155


state 148

    (62) while_expresion -> while v_expr loop expr pool .

    semicolon       reduce using rule 62 (while_expresion -> while v_expr loop expr pool .)
    idx             reduce using rule 62 (while_expresion -> while v_expr loop expr pool .)
    inx             reduce using rule 62 (while_expresion -> while v_expr loop expr pool .)
    of              reduce using rule 62 (while_expresion -> while v_expr loop expr pool .)
    plus            reduce using rule 62 (while_expresion -> while v_expr loop expr pool .)
    minus           reduce using rule 62 (while_expresion -> while v_expr loop expr pool .)
    star            reduce using rule 62 (while_expresion -> while v_expr loop expr pool .)
    div             reduce using rule 62 (while_expresion -> while v_expr loop expr pool .)
    less            reduce using rule 62 (while_expresion -> while v_expr loop expr pool .)
    less_equal      reduce using rule 62 (while_expresion -> while v_expr loop expr pool .)
    equal           reduce using rule 62 (while_expresion -> while v_expr loop expr pool .)
    loop            reduce using rule 62 (while_expresion -> while v_expr loop expr pool .)
    cbracket        reduce using rule 62 (while_expresion -> while v_expr loop expr pool .)
    then            reduce using rule 62 (while_expresion -> while v_expr loop expr pool .)
    ccurly          reduce using rule 62 (while_expresion -> while v_expr loop expr pool .)
    pool            reduce using rule 62 (while_expresion -> while v_expr loop expr pool .)
    else            reduce using rule 62 (while_expresion -> while v_expr loop expr pool .)
    obracket        reduce using rule 62 (while_expresion -> while v_expr loop expr pool .)
    if              reduce using rule 62 (while_expresion -> while v_expr loop expr pool .)
    let             reduce using rule 62 (while_expresion -> while v_expr loop expr pool .)
    case            reduce using rule 62 (while_expresion -> while v_expr loop expr pool .)
    ocurly          reduce using rule 62 (while_expresion -> while v_expr loop expr pool .)
    not             reduce using rule 62 (while_expresion -> while v_expr loop expr pool .)
    complement      reduce using rule 62 (while_expresion -> while v_expr loop expr pool .)
    isvoid          reduce using rule 62 (while_expresion -> while v_expr loop expr pool .)
    new             reduce using rule 62 (while_expresion -> while v_expr loop expr pool .)
    number          reduce using rule 62 (while_expresion -> while v_expr loop expr pool .)
    string          reduce using rule 62 (while_expresion -> while v_expr loop expr pool .)
    true            reduce using rule 62 (while_expresion -> while v_expr loop expr pool .)
    false           reduce using rule 62 (while_expresion -> while v_expr loop expr pool .)
    fi              reduce using rule 62 (while_expresion -> while v_expr loop expr pool .)


state 149

    (60) conditional_expresion -> if v_expr then expr else . expr fi
    (26) expr -> . assign_expresion
    (27) expr -> . while_expresion
    (28) expr -> . v_expr
    (11) assign_expresion -> . idx assign expr
    (62) while_expresion -> . while v_expr loop expr pool
    (32) v_expr -> . conditional_expresion
    (33) v_expr -> . let_expresion
    (34) v_expr -> . case_expresion
    (35) v_expr -> . dispatch_expresion
    (36) v_expr -> . dispatch_instance
    (37) v_expr -> . block_expresion
    (38) v_expr -> . binary_operator
    (39) v_expr -> . neg
    (40) v_expr -> . compl
    (41) v_expr -> . is_void
    (42) v_expr -> . new_expresion
    (43) v_expr -> . obracket v_expr cbracket
    (44) v_expr -> . term
    (45) v_expr -> . comparison_expresion
    (60) conditional_expresion -> . if v_expr then expr else expr fi
    (67) let_expresion -> . let let_declr_list inx expr
    (63) case_expresion -> . case expr of case_list esac
    (71) dispatch_expresion -> . idx obracket dispatch_p_list cbracket
    (72) dispatch_instance -> . idx dot idx obracket dispatch_p_list cbracket
    (73) dispatch_instance -> . idx arrobe idx dot idx obracket dispatch_p_list cbracket
    (55) block_expresion -> . ocurly block_expr ccurly
    (2) binary_operator -> . v_expr plus v_expr
    (3) binary_operator -> . v_expr minus v_expr
    (4) binary_operator -> . v_expr star v_expr
    (5) binary_operator -> . v_expr div v_expr
    (9) neg -> . not idx
    (10) compl -> . complement idx
    (61) is_void -> . isvoid expr
    (15) new_expresion -> . new idx
    (46) term -> . var
    (47) term -> . num
    (48) term -> . str
    (49) term -> . bool
    (29) comparison_expresion -> . v_expr less v_expr
    (30) comparison_expresion -> . v_expr less_equal v_expr
    (31) comparison_expresion -> . v_expr equal v_expr
    (50) var -> . idx
    (51) num -> . number
    (52) str -> . string
    (53) bool -> . true
    (54) bool -> . false

    idx             shift and go to state 44
    while           shift and go to state 49
    obracket        shift and go to state 61
    if              shift and go to state 64
    let             shift and go to state 65
    case            shift and go to state 66
    ocurly          shift and go to state 67
    not             shift and go to state 68
    complement      shift and go to state 69
    isvoid          shift and go to state 70
    new             shift and go to state 71
    number          shift and go to state 76
    string          shift and go to state 77
    true            shift and go to state 78
    false           shift and go to state 79

    v_expr                         shift and go to state 48
    expr                           shift and go to state 156
    assign_expresion               shift and go to state 46
    while_expresion                shift and go to state 47
    conditional_expresion          shift and go to state 50
    let_expresion                  shift and go to state 51
    case_expresion                 shift and go to state 52
    dispatch_expresion             shift and go to state 53
    dispatch_instance              shift and go to state 54
    block_expresion                shift and go to state 55
    binary_operator                shift and go to state 56
    neg                            shift and go to state 57
    compl                          shift and go to state 58
    is_void                        shift and go to state 59
    new_expresion                  shift and go to state 60
    term                           shift and go to state 62
    comparison_expresion           shift and go to state 63
    var                            shift and go to state 72
    num                            shift and go to state 73
    str                            shift and go to state 74
    bool                           shift and go to state 75

state 150

    (63) case_expresion -> case expr of case_list esac .

    plus            reduce using rule 63 (case_expresion -> case expr of case_list esac .)
    minus           reduce using rule 63 (case_expresion -> case expr of case_list esac .)
    star            reduce using rule 63 (case_expresion -> case expr of case_list esac .)
    div             reduce using rule 63 (case_expresion -> case expr of case_list esac .)
    less            reduce using rule 63 (case_expresion -> case expr of case_list esac .)
    less_equal      reduce using rule 63 (case_expresion -> case expr of case_list esac .)
    equal           reduce using rule 63 (case_expresion -> case expr of case_list esac .)
    semicolon       reduce using rule 63 (case_expresion -> case expr of case_list esac .)
    idx             reduce using rule 63 (case_expresion -> case expr of case_list esac .)
    inx             reduce using rule 63 (case_expresion -> case expr of case_list esac .)
    loop            reduce using rule 63 (case_expresion -> case expr of case_list esac .)
    cbracket        reduce using rule 63 (case_expresion -> case expr of case_list esac .)
    then            reduce using rule 63 (case_expresion -> case expr of case_list esac .)
    of              reduce using rule 63 (case_expresion -> case expr of case_list esac .)
    ccurly          reduce using rule 63 (case_expresion -> case expr of case_list esac .)
    pool            reduce using rule 63 (case_expresion -> case expr of case_list esac .)
    else            reduce using rule 63 (case_expresion -> case expr of case_list esac .)
    obracket        reduce using rule 63 (case_expresion -> case expr of case_list esac .)
    if              reduce using rule 63 (case_expresion -> case expr of case_list esac .)
    let             reduce using rule 63 (case_expresion -> case expr of case_list esac .)
    case            reduce using rule 63 (case_expresion -> case expr of case_list esac .)
    ocurly          reduce using rule 63 (case_expresion -> case expr of case_list esac .)
    not             reduce using rule 63 (case_expresion -> case expr of case_list esac .)
    complement      reduce using rule 63 (case_expresion -> case expr of case_list esac .)
    isvoid          reduce using rule 63 (case_expresion -> case expr of case_list esac .)
    new             reduce using rule 63 (case_expresion -> case expr of case_list esac .)
    number          reduce using rule 63 (case_expresion -> case expr of case_list esac .)
    string          reduce using rule 63 (case_expresion -> case expr of case_list esac .)
    true            reduce using rule 63 (case_expresion -> case expr of case_list esac .)
    false           reduce using rule 63 (case_expresion -> case expr of case_list esac .)
    fi              reduce using rule 63 (case_expresion -> case expr of case_list esac .)


state 151

    (64) case_list -> declare_method case_expr . expr semicolon case_list_a
    (26) expr -> . assign_expresion
    (27) expr -> . while_expresion
    (28) expr -> . v_expr
    (11) assign_expresion -> . idx assign expr
    (62) while_expresion -> . while v_expr loop expr pool
    (32) v_expr -> . conditional_expresion
    (33) v_expr -> . let_expresion
    (34) v_expr -> . case_expresion
    (35) v_expr -> . dispatch_expresion
    (36) v_expr -> . dispatch_instance
    (37) v_expr -> . block_expresion
    (38) v_expr -> . binary_operator
    (39) v_expr -> . neg
    (40) v_expr -> . compl
    (41) v_expr -> . is_void
    (42) v_expr -> . new_expresion
    (43) v_expr -> . obracket v_expr cbracket
    (44) v_expr -> . term
    (45) v_expr -> . comparison_expresion
    (60) conditional_expresion -> . if v_expr then expr else expr fi
    (67) let_expresion -> . let let_declr_list inx expr
    (63) case_expresion -> . case expr of case_list esac
    (71) dispatch_expresion -> . idx obracket dispatch_p_list cbracket
    (72) dispatch_instance -> . idx dot idx obracket dispatch_p_list cbracket
    (73) dispatch_instance -> . idx arrobe idx dot idx obracket dispatch_p_list cbracket
    (55) block_expresion -> . ocurly block_expr ccurly
    (2) binary_operator -> . v_expr plus v_expr
    (3) binary_operator -> . v_expr minus v_expr
    (4) binary_operator -> . v_expr star v_expr
    (5) binary_operator -> . v_expr div v_expr
    (9) neg -> . not idx
    (10) compl -> . complement idx
    (61) is_void -> . isvoid expr
    (15) new_expresion -> . new idx
    (46) term -> . var
    (47) term -> . num
    (48) term -> . str
    (49) term -> . bool
    (29) comparison_expresion -> . v_expr less v_expr
    (30) comparison_expresion -> . v_expr less_equal v_expr
    (31) comparison_expresion -> . v_expr equal v_expr
    (50) var -> . idx
    (51) num -> . number
    (52) str -> . string
    (53) bool -> . true
    (54) bool -> . false

    idx             shift and go to state 44
    while           shift and go to state 49
    obracket        shift and go to state 61
    if              shift and go to state 64
    let             shift and go to state 65
    case            shift and go to state 66
    ocurly          shift and go to state 67
    not             shift and go to state 68
    complement      shift and go to state 69
    isvoid          shift and go to state 70
    new             shift and go to state 71
    number          shift and go to state 76
    string          shift and go to state 77
    true            shift and go to state 78
    false           shift and go to state 79

    expr                           shift and go to state 157
    assign_expresion               shift and go to state 46
    while_expresion                shift and go to state 47
    v_expr                         shift and go to state 48
    conditional_expresion          shift and go to state 50
    let_expresion                  shift and go to state 51
    case_expresion                 shift and go to state 52
    dispatch_expresion             shift and go to state 53
    dispatch_instance              shift and go to state 54
    block_expresion                shift and go to state 55
    binary_operator                shift and go to state 56
    neg                            shift and go to state 57
    compl                          shift and go to state 58
    is_void                        shift and go to state 59
    new_expresion                  shift and go to state 60
    term                           shift and go to state 62
    comparison_expresion           shift and go to state 63
    var                            shift and go to state 72
    num                            shift and go to state 73
    str                            shift and go to state 74
    bool                           shift and go to state 75

state 152

    (57) block_expr_a -> expr semicolon . block_expr_a
    (57) block_expr_a -> . expr semicolon block_expr_a
    (58) block_expr_a -> . empty
    (26) expr -> . assign_expresion
    (27) expr -> . while_expresion
    (28) expr -> . v_expr
    (1) empty -> .
    (11) assign_expresion -> . idx assign expr
    (62) while_expresion -> . while v_expr loop expr pool
    (32) v_expr -> . conditional_expresion
    (33) v_expr -> . let_expresion
    (34) v_expr -> . case_expresion
    (35) v_expr -> . dispatch_expresion
    (36) v_expr -> . dispatch_instance
    (37) v_expr -> . block_expresion
    (38) v_expr -> . binary_operator
    (39) v_expr -> . neg
    (40) v_expr -> . compl
    (41) v_expr -> . is_void
    (42) v_expr -> . new_expresion
    (43) v_expr -> . obracket v_expr cbracket
    (44) v_expr -> . term
    (45) v_expr -> . comparison_expresion
    (60) conditional_expresion -> . if v_expr then expr else expr fi
    (67) let_expresion -> . let let_declr_list inx expr
    (63) case_expresion -> . case expr of case_list esac
    (71) dispatch_expresion -> . idx obracket dispatch_p_list cbracket
    (72) dispatch_instance -> . idx dot idx obracket dispatch_p_list cbracket
    (73) dispatch_instance -> . idx arrobe idx dot idx obracket dispatch_p_list cbracket
    (55) block_expresion -> . ocurly block_expr ccurly
    (2) binary_operator -> . v_expr plus v_expr
    (3) binary_operator -> . v_expr minus v_expr
    (4) binary_operator -> . v_expr star v_expr
    (5) binary_operator -> . v_expr div v_expr
    (9) neg -> . not idx
    (10) compl -> . complement idx
    (61) is_void -> . isvoid expr
    (15) new_expresion -> . new idx
    (46) term -> . var
    (47) term -> . num
    (48) term -> . str
    (49) term -> . bool
    (29) comparison_expresion -> . v_expr less v_expr
    (30) comparison_expresion -> . v_expr less_equal v_expr
    (31) comparison_expresion -> . v_expr equal v_expr
    (50) var -> . idx
    (51) num -> . number
    (52) str -> . string
    (53) bool -> . true
    (54) bool -> . false

    ccurly          reduce using rule 1 (empty -> .)
    idx             shift and go to state 44
    while           shift and go to state 49
    obracket        shift and go to state 61
    if              shift and go to state 64
    let             shift and go to state 65
    case            shift and go to state 66
    ocurly          shift and go to state 67
    not             shift and go to state 68
    complement      shift and go to state 69
    isvoid          shift and go to state 70
    new             shift and go to state 71
    number          shift and go to state 76
    string          shift and go to state 77
    true            shift and go to state 78
    false           shift and go to state 79

    expr                           shift and go to state 142
    block_expr_a                   shift and go to state 158
    empty                          shift and go to state 144
    assign_expresion               shift and go to state 46
    while_expresion                shift and go to state 47
    v_expr                         shift and go to state 48
    conditional_expresion          shift and go to state 50
    let_expresion                  shift and go to state 51
    case_expresion                 shift and go to state 52
    dispatch_expresion             shift and go to state 53
    dispatch_instance              shift and go to state 54
    block_expresion                shift and go to state 55
    binary_operator                shift and go to state 56
    neg                            shift and go to state 57
    compl                          shift and go to state 58
    is_void                        shift and go to state 59
    new_expresion                  shift and go to state 60
    term                           shift and go to state 62
    comparison_expresion           shift and go to state 63
    var                            shift and go to state 72
    num                            shift and go to state 73
    str                            shift and go to state 74
    bool                           shift and go to state 75

state 153

    (21) method_decl -> idx obracket formal cbracket doubledot idx ocurly expr ccurly semicolon . feature
    (18) feature -> . method_decl feature
    (19) feature -> . property_decl feature
    (20) feature -> . ccurly
    (21) method_decl -> . idx obracket formal cbracket doubledot idx ocurly expr ccurly semicolon feature
    (59) property_decl -> . declare_expresion semicolon feature
    (12) declare_expresion -> . idx doubledot idx assign expr
    (13) declare_expresion -> . idx doubledot idx

    ccurly          shift and go to state 20
    idx             shift and go to state 16

    feature                        shift and go to state 159
    method_decl                    shift and go to state 18
    property_decl                  shift and go to state 19
    declare_expresion              shift and go to state 21

state 154

    (72) dispatch_instance -> idx dot idx obracket dispatch_p_list cbracket .

    plus            reduce using rule 72 (dispatch_instance -> idx dot idx obracket dispatch_p_list cbracket .)
    minus           reduce using rule 72 (dispatch_instance -> idx dot idx obracket dispatch_p_list cbracket .)
    star            reduce using rule 72 (dispatch_instance -> idx dot idx obracket dispatch_p_list cbracket .)
    div             reduce using rule 72 (dispatch_instance -> idx dot idx obracket dispatch_p_list cbracket .)
    less            reduce using rule 72 (dispatch_instance -> idx dot idx obracket dispatch_p_list cbracket .)
    less_equal      reduce using rule 72 (dispatch_instance -> idx dot idx obracket dispatch_p_list cbracket .)
    equal           reduce using rule 72 (dispatch_instance -> idx dot idx obracket dispatch_p_list cbracket .)
    semicolon       reduce using rule 72 (dispatch_instance -> idx dot idx obracket dispatch_p_list cbracket .)
    idx             reduce using rule 72 (dispatch_instance -> idx dot idx obracket dispatch_p_list cbracket .)
    inx             reduce using rule 72 (dispatch_instance -> idx dot idx obracket dispatch_p_list cbracket .)
    loop            reduce using rule 72 (dispatch_instance -> idx dot idx obracket dispatch_p_list cbracket .)
    cbracket        reduce using rule 72 (dispatch_instance -> idx dot idx obracket dispatch_p_list cbracket .)
    then            reduce using rule 72 (dispatch_instance -> idx dot idx obracket dispatch_p_list cbracket .)
    of              reduce using rule 72 (dispatch_instance -> idx dot idx obracket dispatch_p_list cbracket .)
    ccurly          reduce using rule 72 (dispatch_instance -> idx dot idx obracket dispatch_p_list cbracket .)
    pool            reduce using rule 72 (dispatch_instance -> idx dot idx obracket dispatch_p_list cbracket .)
    else            reduce using rule 72 (dispatch_instance -> idx dot idx obracket dispatch_p_list cbracket .)
    obracket        reduce using rule 72 (dispatch_instance -> idx dot idx obracket dispatch_p_list cbracket .)
    if              reduce using rule 72 (dispatch_instance -> idx dot idx obracket dispatch_p_list cbracket .)
    let             reduce using rule 72 (dispatch_instance -> idx dot idx obracket dispatch_p_list cbracket .)
    case            reduce using rule 72 (dispatch_instance -> idx dot idx obracket dispatch_p_list cbracket .)
    ocurly          reduce using rule 72 (dispatch_instance -> idx dot idx obracket dispatch_p_list cbracket .)
    not             reduce using rule 72 (dispatch_instance -> idx dot idx obracket dispatch_p_list cbracket .)
    complement      reduce using rule 72 (dispatch_instance -> idx dot idx obracket dispatch_p_list cbracket .)
    isvoid          reduce using rule 72 (dispatch_instance -> idx dot idx obracket dispatch_p_list cbracket .)
    new             reduce using rule 72 (dispatch_instance -> idx dot idx obracket dispatch_p_list cbracket .)
    number          reduce using rule 72 (dispatch_instance -> idx dot idx obracket dispatch_p_list cbracket .)
    string          reduce using rule 72 (dispatch_instance -> idx dot idx obracket dispatch_p_list cbracket .)
    true            reduce using rule 72 (dispatch_instance -> idx dot idx obracket dispatch_p_list cbracket .)
    false           reduce using rule 72 (dispatch_instance -> idx dot idx obracket dispatch_p_list cbracket .)
    fi              reduce using rule 72 (dispatch_instance -> idx dot idx obracket dispatch_p_list cbracket .)


state 155

    (73) dispatch_instance -> idx arrobe idx dot idx obracket . dispatch_p_list cbracket
    (74) dispatch_p_list -> . v_expr dispatch_p_list
    (75) dispatch_p_list -> . empty
    (32) v_expr -> . conditional_expresion
    (33) v_expr -> . let_expresion
    (34) v_expr -> . case_expresion
    (35) v_expr -> . dispatch_expresion
    (36) v_expr -> . dispatch_instance
    (37) v_expr -> . block_expresion
    (38) v_expr -> . binary_operator
    (39) v_expr -> . neg
    (40) v_expr -> . compl
    (41) v_expr -> . is_void
    (42) v_expr -> . new_expresion
    (43) v_expr -> . obracket v_expr cbracket
    (44) v_expr -> . term
    (45) v_expr -> . comparison_expresion
    (1) empty -> .
    (60) conditional_expresion -> . if v_expr then expr else expr fi
    (67) let_expresion -> . let let_declr_list inx expr
    (63) case_expresion -> . case expr of case_list esac
    (71) dispatch_expresion -> . idx obracket dispatch_p_list cbracket
    (72) dispatch_instance -> . idx dot idx obracket dispatch_p_list cbracket
    (73) dispatch_instance -> . idx arrobe idx dot idx obracket dispatch_p_list cbracket
    (55) block_expresion -> . ocurly block_expr ccurly
    (2) binary_operator -> . v_expr plus v_expr
    (3) binary_operator -> . v_expr minus v_expr
    (4) binary_operator -> . v_expr star v_expr
    (5) binary_operator -> . v_expr div v_expr
    (9) neg -> . not idx
    (10) compl -> . complement idx
    (61) is_void -> . isvoid expr
    (15) new_expresion -> . new idx
    (46) term -> . var
    (47) term -> . num
    (48) term -> . str
    (49) term -> . bool
    (29) comparison_expresion -> . v_expr less v_expr
    (30) comparison_expresion -> . v_expr less_equal v_expr
    (31) comparison_expresion -> . v_expr equal v_expr
    (50) var -> . idx
    (51) num -> . number
    (52) str -> . string
    (53) bool -> . true
    (54) bool -> . false

    obracket        shift and go to state 61
    cbracket        reduce using rule 1 (empty -> .)
    if              shift and go to state 64
    let             shift and go to state 65
    case            shift and go to state 66
    idx             shift and go to state 94
    ocurly          shift and go to state 67
    not             shift and go to state 68
    complement      shift and go to state 69
    isvoid          shift and go to state 70
    new             shift and go to state 71
    number          shift and go to state 76
    string          shift and go to state 77
    true            shift and go to state 78
    false           shift and go to state 79

    dispatch_p_list                shift and go to state 160
    v_expr                         shift and go to state 110
    empty                          shift and go to state 111
    conditional_expresion          shift and go to state 50
    let_expresion                  shift and go to state 51
    case_expresion                 shift and go to state 52
    dispatch_expresion             shift and go to state 53
    dispatch_instance              shift and go to state 54
    block_expresion                shift and go to state 55
    binary_operator                shift and go to state 56
    neg                            shift and go to state 57
    compl                          shift and go to state 58
    is_void                        shift and go to state 59
    new_expresion                  shift and go to state 60
    term                           shift and go to state 62
    comparison_expresion           shift and go to state 63
    var                            shift and go to state 72
    num                            shift and go to state 73
    str                            shift and go to state 74
    bool                           shift and go to state 75

state 156

    (60) conditional_expresion -> if v_expr then expr else expr . fi

    fi              shift and go to state 161


state 157

    (64) case_list -> declare_method case_expr expr . semicolon case_list_a

    semicolon       shift and go to state 162


state 158

    (57) block_expr_a -> expr semicolon block_expr_a .

    ccurly          reduce using rule 57 (block_expr_a -> expr semicolon block_expr_a .)


state 159

    (21) method_decl -> idx obracket formal cbracket doubledot idx ocurly expr ccurly semicolon feature .

    ccurly          reduce using rule 21 (method_decl -> idx obracket formal cbracket doubledot idx ocurly expr ccurly semicolon feature .)
    idx             reduce using rule 21 (method_decl -> idx obracket formal cbracket doubledot idx ocurly expr ccurly semicolon feature .)


state 160

    (73) dispatch_instance -> idx arrobe idx dot idx obracket dispatch_p_list . cbracket

    cbracket        shift and go to state 163


state 161

    (60) conditional_expresion -> if v_expr then expr else expr fi .

    plus            reduce using rule 60 (conditional_expresion -> if v_expr then expr else expr fi .)
    minus           reduce using rule 60 (conditional_expresion -> if v_expr then expr else expr fi .)
    star            reduce using rule 60 (conditional_expresion -> if v_expr then expr else expr fi .)
    div             reduce using rule 60 (conditional_expresion -> if v_expr then expr else expr fi .)
    less            reduce using rule 60 (conditional_expresion -> if v_expr then expr else expr fi .)
    less_equal      reduce using rule 60 (conditional_expresion -> if v_expr then expr else expr fi .)
    equal           reduce using rule 60 (conditional_expresion -> if v_expr then expr else expr fi .)
    semicolon       reduce using rule 60 (conditional_expresion -> if v_expr then expr else expr fi .)
    idx             reduce using rule 60 (conditional_expresion -> if v_expr then expr else expr fi .)
    inx             reduce using rule 60 (conditional_expresion -> if v_expr then expr else expr fi .)
    loop            reduce using rule 60 (conditional_expresion -> if v_expr then expr else expr fi .)
    cbracket        reduce using rule 60 (conditional_expresion -> if v_expr then expr else expr fi .)
    then            reduce using rule 60 (conditional_expresion -> if v_expr then expr else expr fi .)
    of              reduce using rule 60 (conditional_expresion -> if v_expr then expr else expr fi .)
    ccurly          reduce using rule 60 (conditional_expresion -> if v_expr then expr else expr fi .)
    pool            reduce using rule 60 (conditional_expresion -> if v_expr then expr else expr fi .)
    else            reduce using rule 60 (conditional_expresion -> if v_expr then expr else expr fi .)
    obracket        reduce using rule 60 (conditional_expresion -> if v_expr then expr else expr fi .)
    if              reduce using rule 60 (conditional_expresion -> if v_expr then expr else expr fi .)
    let             reduce using rule 60 (conditional_expresion -> if v_expr then expr else expr fi .)
    case            reduce using rule 60 (conditional_expresion -> if v_expr then expr else expr fi .)
    ocurly          reduce using rule 60 (conditional_expresion -> if v_expr then expr else expr fi .)
    not             reduce using rule 60 (conditional_expresion -> if v_expr then expr else expr fi .)
    complement      reduce using rule 60 (conditional_expresion -> if v_expr then expr else expr fi .)
    isvoid          reduce using rule 60 (conditional_expresion -> if v_expr then expr else expr fi .)
    new             reduce using rule 60 (conditional_expresion -> if v_expr then expr else expr fi .)
    number          reduce using rule 60 (conditional_expresion -> if v_expr then expr else expr fi .)
    string          reduce using rule 60 (conditional_expresion -> if v_expr then expr else expr fi .)
    true            reduce using rule 60 (conditional_expresion -> if v_expr then expr else expr fi .)
    false           reduce using rule 60 (conditional_expresion -> if v_expr then expr else expr fi .)
    fi              reduce using rule 60 (conditional_expresion -> if v_expr then expr else expr fi .)


state 162

    (64) case_list -> declare_method case_expr expr semicolon . case_list_a
    (65) case_list_a -> . declare_method case_expr expr semicolon case_list_a
    (66) case_list_a -> . empty
    (14) declare_method -> . idx doubledot idx
    (1) empty -> .

    idx             shift and go to state 29
    esac            reduce using rule 1 (empty -> .)

    declare_method                 shift and go to state 164
    case_list_a                    shift and go to state 165
    empty                          shift and go to state 166

state 163

    (73) dispatch_instance -> idx arrobe idx dot idx obracket dispatch_p_list cbracket .

    plus            reduce using rule 73 (dispatch_instance -> idx arrobe idx dot idx obracket dispatch_p_list cbracket .)
    minus           reduce using rule 73 (dispatch_instance -> idx arrobe idx dot idx obracket dispatch_p_list cbracket .)
    star            reduce using rule 73 (dispatch_instance -> idx arrobe idx dot idx obracket dispatch_p_list cbracket .)
    div             reduce using rule 73 (dispatch_instance -> idx arrobe idx dot idx obracket dispatch_p_list cbracket .)
    less            reduce using rule 73 (dispatch_instance -> idx arrobe idx dot idx obracket dispatch_p_list cbracket .)
    less_equal      reduce using rule 73 (dispatch_instance -> idx arrobe idx dot idx obracket dispatch_p_list cbracket .)
    equal           reduce using rule 73 (dispatch_instance -> idx arrobe idx dot idx obracket dispatch_p_list cbracket .)
    semicolon       reduce using rule 73 (dispatch_instance -> idx arrobe idx dot idx obracket dispatch_p_list cbracket .)
    idx             reduce using rule 73 (dispatch_instance -> idx arrobe idx dot idx obracket dispatch_p_list cbracket .)
    inx             reduce using rule 73 (dispatch_instance -> idx arrobe idx dot idx obracket dispatch_p_list cbracket .)
    loop            reduce using rule 73 (dispatch_instance -> idx arrobe idx dot idx obracket dispatch_p_list cbracket .)
    cbracket        reduce using rule 73 (dispatch_instance -> idx arrobe idx dot idx obracket dispatch_p_list cbracket .)
    then            reduce using rule 73 (dispatch_instance -> idx arrobe idx dot idx obracket dispatch_p_list cbracket .)
    of              reduce using rule 73 (dispatch_instance -> idx arrobe idx dot idx obracket dispatch_p_list cbracket .)
    ccurly          reduce using rule 73 (dispatch_instance -> idx arrobe idx dot idx obracket dispatch_p_list cbracket .)
    pool            reduce using rule 73 (dispatch_instance -> idx arrobe idx dot idx obracket dispatch_p_list cbracket .)
    else            reduce using rule 73 (dispatch_instance -> idx arrobe idx dot idx obracket dispatch_p_list cbracket .)
    obracket        reduce using rule 73 (dispatch_instance -> idx arrobe idx dot idx obracket dispatch_p_list cbracket .)
    if              reduce using rule 73 (dispatch_instance -> idx arrobe idx dot idx obracket dispatch_p_list cbracket .)
    let             reduce using rule 73 (dispatch_instance -> idx arrobe idx dot idx obracket dispatch_p_list cbracket .)
    case            reduce using rule 73 (dispatch_instance -> idx arrobe idx dot idx obracket dispatch_p_list cbracket .)
    ocurly          reduce using rule 73 (dispatch_instance -> idx arrobe idx dot idx obracket dispatch_p_list cbracket .)
    not             reduce using rule 73 (dispatch_instance -> idx arrobe idx dot idx obracket dispatch_p_list cbracket .)
    complement      reduce using rule 73 (dispatch_instance -> idx arrobe idx dot idx obracket dispatch_p_list cbracket .)
    isvoid          reduce using rule 73 (dispatch_instance -> idx arrobe idx dot idx obracket dispatch_p_list cbracket .)
    new             reduce using rule 73 (dispatch_instance -> idx arrobe idx dot idx obracket dispatch_p_list cbracket .)
    number          reduce using rule 73 (dispatch_instance -> idx arrobe idx dot idx obracket dispatch_p_list cbracket .)
    string          reduce using rule 73 (dispatch_instance -> idx arrobe idx dot idx obracket dispatch_p_list cbracket .)
    true            reduce using rule 73 (dispatch_instance -> idx arrobe idx dot idx obracket dispatch_p_list cbracket .)
    false           reduce using rule 73 (dispatch_instance -> idx arrobe idx dot idx obracket dispatch_p_list cbracket .)
    fi              reduce using rule 73 (dispatch_instance -> idx arrobe idx dot idx obracket dispatch_p_list cbracket .)


state 164

    (65) case_list_a -> declare_method . case_expr expr semicolon case_list_a

    case_expr       shift and go to state 167


state 165

    (64) case_list -> declare_method case_expr expr semicolon case_list_a .

    esac            reduce using rule 64 (case_list -> declare_method case_expr expr semicolon case_list_a .)


state 166

    (66) case_list_a -> empty .

    esac            reduce using rule 66 (case_list_a -> empty .)


state 167

    (65) case_list_a -> declare_method case_expr . expr semicolon case_list_a
    (26) expr -> . assign_expresion
    (27) expr -> . while_expresion
    (28) expr -> . v_expr
    (11) assign_expresion -> . idx assign expr
    (62) while_expresion -> . while v_expr loop expr pool
    (32) v_expr -> . conditional_expresion
    (33) v_expr -> . let_expresion
    (34) v_expr -> . case_expresion
    (35) v_expr -> . dispatch_expresion
    (36) v_expr -> . dispatch_instance
    (37) v_expr -> . block_expresion
    (38) v_expr -> . binary_operator
    (39) v_expr -> . neg
    (40) v_expr -> . compl
    (41) v_expr -> . is_void
    (42) v_expr -> . new_expresion
    (43) v_expr -> . obracket v_expr cbracket
    (44) v_expr -> . term
    (45) v_expr -> . comparison_expresion
    (60) conditional_expresion -> . if v_expr then expr else expr fi
    (67) let_expresion -> . let let_declr_list inx expr
    (63) case_expresion -> . case expr of case_list esac
    (71) dispatch_expresion -> . idx obracket dispatch_p_list cbracket
    (72) dispatch_instance -> . idx dot idx obracket dispatch_p_list cbracket
    (73) dispatch_instance -> . idx arrobe idx dot idx obracket dispatch_p_list cbracket
    (55) block_expresion -> . ocurly block_expr ccurly
    (2) binary_operator -> . v_expr plus v_expr
    (3) binary_operator -> . v_expr minus v_expr
    (4) binary_operator -> . v_expr star v_expr
    (5) binary_operator -> . v_expr div v_expr
    (9) neg -> . not idx
    (10) compl -> . complement idx
    (61) is_void -> . isvoid expr
    (15) new_expresion -> . new idx
    (46) term -> . var
    (47) term -> . num
    (48) term -> . str
    (49) term -> . bool
    (29) comparison_expresion -> . v_expr less v_expr
    (30) comparison_expresion -> . v_expr less_equal v_expr
    (31) comparison_expresion -> . v_expr equal v_expr
    (50) var -> . idx
    (51) num -> . number
    (52) str -> . string
    (53) bool -> . true
    (54) bool -> . false

    idx             shift and go to state 44
    while           shift and go to state 49
    obracket        shift and go to state 61
    if              shift and go to state 64
    let             shift and go to state 65
    case            shift and go to state 66
    ocurly          shift and go to state 67
    not             shift and go to state 68
    complement      shift and go to state 69
    isvoid          shift and go to state 70
    new             shift and go to state 71
    number          shift and go to state 76
    string          shift and go to state 77
    true            shift and go to state 78
    false           shift and go to state 79

    expr                           shift and go to state 168
    assign_expresion               shift and go to state 46
    while_expresion                shift and go to state 47
    v_expr                         shift and go to state 48
    conditional_expresion          shift and go to state 50
    let_expresion                  shift and go to state 51
    case_expresion                 shift and go to state 52
    dispatch_expresion             shift and go to state 53
    dispatch_instance              shift and go to state 54
    block_expresion                shift and go to state 55
    binary_operator                shift and go to state 56
    neg                            shift and go to state 57
    compl                          shift and go to state 58
    is_void                        shift and go to state 59
    new_expresion                  shift and go to state 60
    term                           shift and go to state 62
    comparison_expresion           shift and go to state 63
    var                            shift and go to state 72
    num                            shift and go to state 73
    str                            shift and go to state 74
    bool                           shift and go to state 75

state 168

    (65) case_list_a -> declare_method case_expr expr . semicolon case_list_a

    semicolon       shift and go to state 169


state 169

    (65) case_list_a -> declare_method case_expr expr semicolon . case_list_a
    (65) case_list_a -> . declare_method case_expr expr semicolon case_list_a
    (66) case_list_a -> . empty
    (14) declare_method -> . idx doubledot idx
    (1) empty -> .

    idx             shift and go to state 29
    esac            reduce using rule 1 (empty -> .)

    declare_method                 shift and go to state 164
    case_list_a                    shift and go to state 170
    empty                          shift and go to state 166

state 170

    (65) case_list_a -> declare_method case_expr expr semicolon case_list_a .

    esac            reduce using rule 65 (case_list_a -> declare_method case_expr expr semicolon case_list_a .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for obracket in state 44 resolved as shift
WARNING: shift/reduce conflict for plus in state 48 resolved as shift
WARNING: shift/reduce conflict for minus in state 48 resolved as shift
WARNING: shift/reduce conflict for star in state 48 resolved as shift
WARNING: shift/reduce conflict for div in state 48 resolved as shift
WARNING: shift/reduce conflict for less in state 48 resolved as shift
WARNING: shift/reduce conflict for less_equal in state 48 resolved as shift
WARNING: shift/reduce conflict for equal in state 48 resolved as shift
WARNING: shift/reduce conflict for obracket in state 94 resolved as shift
